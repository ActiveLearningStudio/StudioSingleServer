/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 20);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(18)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(17);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _ScoreInput = __webpack_require__(29);

var _ScoreInput2 = _interopRequireDefault(_ScoreInput);

var _TextInput = __webpack_require__(30);

var _TextInput2 = _interopRequireDefault(_TextInput);

var _Final = __webpack_require__(28);

var _Final2 = _interopRequireDefault(_Final);

var _xapi = __webpack_require__(21);

var _xapi2 = _interopRequireDefault(_xapi);

var _face = __webpack_require__(24);

var _face2 = _interopRequireDefault(_face);

var _face3 = __webpack_require__(25);

var _face4 = _interopRequireDefault(_face3);

var _face5 = __webpack_require__(26);

var _face6 = _interopRequireDefault(_face5);

var _face7 = __webpack_require__(27);

var _face8 = _interopRequireDefault(_face7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

_vue2.default.use(_vueRouter2.default);

var Feedback = function (_H5P$EventDispatcher) {
  _inherits(Feedback, _H5P$EventDispatcher);

  /**
   * @constructor
   *
   * @param {object} config
   * @param {string} contentId
   * @param {object} contentData
   */
  function Feedback(config, contentId) {
    var contentData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Feedback);

    var _this = _possibleConstructorReturn(this, (Feedback.__proto__ || Object.getPrototypeOf(Feedback)).call(this));

    _this.contentId = contentId;
    _this.xapi = new _xapi2.default();

    var state = contentData.previousState || {};

    var alternatives = [{
      title: config.l10n.scaleVerySatisfied,
      cls: 'feedback-score-4',
      score: '4',
      icon: _face8.default
    }, {
      title: config.l10n.scaleSatisfied,
      cls: 'feedback-score-3',
      score: '3',
      icon: _face6.default
    }, {
      title: config.l10n.scaleNeutral,
      cls: 'feedback-score-2',
      score: '2',
      icon: _face4.default
    }, {
      title: config.l10n.scaleUnsatisfied,
      cls: 'feedback-score-1',
      score: '1',
      icon: _face2.default
    }];

    // set data on text input view
    _TextInput2.default.data = function () {
      return {
        alternatives: alternatives,
        text: '',
        labelTextInput: config.labelTextInput
      };
    };

    // crate router
    var router = new _vueRouter2.default({
      mode: 'abstract',
      routes: [{ path: '/score-input', component: _ScoreInput2.default, props: { alternatives: alternatives, message: config.labelScoreInput } }, { path: '/text-input/:score', component: _TextInput2.default, props: true }, { path: '/final', component: _Final2.default, props: { finishedText: config.finishedText } }, { path: '/', redirect: '/score-input' }]
    });

    // trigger resize when switching views
    router.beforeEach(function (to, from, next) {
      next();
      _this.trigger('resize');
    });

    // create view model
    _this.viewModel = new _vue2.default({ router: router });

    // update state
    router.app.$on('submit-score', function (score) {
      return state.score = score;
    });
    router.app.$on('submit-text', function (responseText) {
      return state.responseText = responseText;
    });

    // fire xapi events on score or text response updates
    router.app.$on('submit-score', function (score) {
      var scale = alternatives.map(_this.alternativeeToScale);
      var event = _this.createXAPIEventTemplate('answered');
      _this.xapi.createLikertEvent(event, config.labelScoreInput, score, scale);
      _this.trigger(event);
    });

    router.app.$on('submit-text', function (responseText) {
      var event = _this.createXAPIEventTemplate('answered');
      _this.xapi.createTextEvent(event, responseText);
      _this.trigger(event);
    });

    /**
     * Attach library to wrapper
     *
     * @param {jQuery} $wrapper
     * @public
     */
    _this.attach = function ($wrapper) {
      var id = 'h5p-feedback-content-' + _this.contentId;
      $wrapper.get(0).appendChild(_this.createRootElement(id));
      _this.viewModel.$mount('#' + id);
      router.push('score-input');
    };

    /**
     * Returns the current state
     *
     * @return {object}
     */
    _this.getCurrentState = function () {
      return state;
    };

    /**
     * Creates the root element that vue will render into
     *
     * @param {string} id
     *
     * @return {Element}
     */
    _this.createRootElement = function (id) {
      var element = document.createElement('div');
      element.id = id;
      element.className = 'h5p-feedback';
      element.innerHTML = '<router-view></router-view>';
      return element;
    };

    /**
     * Returns an array of xAPI scale objects when given a an
     * array of alternatives
     *
     * @param {object[]} alternative
     */
    _this.alternativeeToScale = function (alternative) {
      return {
        id: alternative.score,
        description: _this.xapi.wrapAsTranslation(alternative.title)
      };
    };
    return _this;
  }

  return Feedback;
}(H5P.EventDispatcher);

exports.default = Feedback;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(6);
var ieee754 = __webpack_require__(8);
var isArray = __webpack_require__(9);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(10)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (global) {

    // minimal symbol polyfill for IE11 and others
    if (typeof _Symbol !== 'function') {
        var _Symbol = function _Symbol(name) {
            return name;
        };

        _Symbol.nonNative = true;
    }

    var STATE_PLAINTEXT = _Symbol('plaintext');
    var STATE_HTML = _Symbol('html');
    var STATE_COMMENT = _Symbol('comment');

    var ALLOWED_TAGS_REGEX = /<(\w*)>/g;
    var NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;

    function striptags(html, allowable_tags, tag_replacement) {
        html = html || '';
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || '';

        var context = init_context(allowable_tags, tag_replacement);

        return striptags_internal(html, context);
    }

    function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || '';

        var context = init_context(allowable_tags, tag_replacement);

        return function striptags_stream(html) {
            return striptags_internal(html || '', context);
        };
    }

    striptags.init_streaming_mode = init_striptags_stream;

    function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);

        return {
            allowable_tags: allowable_tags,
            tag_replacement: tag_replacement,

            state: STATE_PLAINTEXT,
            tag_buffer: '',
            depth: 0,
            in_quote_char: ''
        };
    }

    function striptags_internal(html, context) {
        if (typeof html != "string") {
            throw new TypeError("'html' parameter must be a string");
        }

        var allowable_tags = context.allowable_tags;
        var tag_replacement = context.tag_replacement;

        var state = context.state;
        var tag_buffer = context.tag_buffer;
        var depth = context.depth;
        var in_quote_char = context.in_quote_char;
        var output = '';

        for (var idx = 0, length = html.length; idx < length; idx++) {
            var char = html[idx];

            if (state === STATE_PLAINTEXT) {
                switch (char) {
                    case '<':
                        state = STATE_HTML;
                        tag_buffer += char;
                        break;

                    default:
                        output += char;
                        break;
                }
            } else if (state === STATE_HTML) {
                switch (char) {
                    case '<':
                        // ignore '<' if inside a quote
                        if (in_quote_char) {
                            break;
                        }

                        // we're seeing a nested '<'
                        depth++;
                        break;

                    case '>':
                        // ignore '>' if inside a quote
                        if (in_quote_char) {
                            break;
                        }

                        // something like this is happening: '<<>>'
                        if (depth) {
                            depth--;

                            break;
                        }

                        // this is closing the tag in tag_buffer
                        in_quote_char = '';
                        state = STATE_PLAINTEXT;
                        tag_buffer += '>';

                        if (allowable_tags.has(normalize_tag(tag_buffer))) {
                            output += tag_buffer;
                        } else {
                            output += tag_replacement;
                        }

                        tag_buffer = '';
                        break;

                    case '"':
                    case '\'':
                        // catch both single and double quotes

                        if (char === in_quote_char) {
                            in_quote_char = '';
                        } else {
                            in_quote_char = in_quote_char || char;
                        }

                        tag_buffer += char;
                        break;

                    case '-':
                        if (tag_buffer === '<!-') {
                            state = STATE_COMMENT;
                        }

                        tag_buffer += char;
                        break;

                    case ' ':
                    case '\n':
                        if (tag_buffer === '<') {
                            state = STATE_PLAINTEXT;
                            output += '< ';
                            tag_buffer = '';

                            break;
                        }

                        tag_buffer += char;
                        break;

                    default:
                        tag_buffer += char;
                        break;
                }
            } else if (state === STATE_COMMENT) {
                switch (char) {
                    case '>':
                        if (tag_buffer.slice(-2) == '--') {
                            // close the comment
                            state = STATE_PLAINTEXT;
                        }

                        tag_buffer = '';
                        break;

                    default:
                        tag_buffer += char;
                        break;
                }
            }
        }

        // save the context for future iterations
        context.state = state;
        context.tag_buffer = tag_buffer;
        context.depth = depth;
        context.in_quote_char = in_quote_char;

        return output;
    }

    function parse_allowable_tags(allowable_tags) {
        var tag_set = new Set();

        if (typeof allowable_tags === 'string') {
            var match = void 0;

            while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {
                tag_set.add(match[1]);
            }
        } else if (!_Symbol.nonNative && typeof allowable_tags[_Symbol.iterator] === 'function') {

            tag_set = new Set(allowable_tags);
        } else if (typeof allowable_tags.forEach === 'function') {
            // IE11 compatible
            allowable_tags.forEach(tag_set.add, tag_set);
        }

        return tag_set;
    }

    function normalize_tag(tag_buffer) {
        var match = NORMALIZE_TAG_REGEX.exec(tag_buffer);

        return match ? match[1].toLowerCase() : null;
    }

    if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function module_factory() {
            return striptags;
        }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
        // Node
        module.exports = striptags;
    } else {
        // Browser
        global.striptags = striptags;
    }
})(undefined);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(11);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || undefined && undefined.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || undefined && undefined.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//

exports.default = {
  name: 'final-view',
  props: ['finishedText']
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'score-input-view',
  props: ['alternatives', 'message'],

  data: function data() {
    return {
      score: '0'
    };
  },

  methods: {
    sendScore: function sendScore(alternative) {
      this.score = alternative.score;
      this.$router.app.$emit('submit-score', alternative.score);
      this.$router.push('text-input/' + alternative.score);
    }
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'text-input-view',
  props: ['score'],

  computed: {
    alternative: function alternative() {
      var _this = this;

      return this.alternatives.filter(function (alternative) {
        return alternative.score === _this.score;
      })[0];
    }
  },

  methods: {
    sendText: function sendText(text) {
      this.$router.app.$emit('submit-text', text);
      this.$router.push('/final');
    }
  }
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
  * vue-router v2.8.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (undefined !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    }

    // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);
    if (propsToPass) {
      // clone to prevent mutation
      propsToPass = data.props = extend({}, propsToPass);
      // pass non-declared props as attrs
      var attrs = data.attrs = data.attrs || {};
      for (var key in propsToPass) {
        if (!component.props || !(key in component.props)) {
          attrs[key] = propsToPass[key];
          delete propsToPass[key];
        }
      }
    }

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config === 'undefined' ? 'undefined' : _typeof(config)) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      if (undefined !== 'production') {
        warn(false, "props in \"" + route.path + "\" is a " + (typeof config === 'undefined' ? 'undefined' : _typeof(config)) + ", " + "expecting an object, function or boolean.");
      }
  }
}

function extend(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to;
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function encode(str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    undefined !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }
  return parsedQuery;
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;

  var query = location.query || {};
  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route);
}

function clone(value) {
  if (Array.isArray(value)) {
    return value.map(clone);
  } else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
    var res = {};
    for (var key in value) {
      res[key] = clone(value[key]);
    }
    return res;
  } else {
    return value;
  }
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  // handle null value #1566
  if (!a || !b) {
    return a === b;
  }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if ((typeof aVal === 'undefined' ? 'undefined' : _typeof(aVal)) === 'object' && (typeof bVal === 'undefined' ? 'undefined' : _typeof(bVal)) === 'object') {
      return isObjectEqual(aVal, bVal);
    }
    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function handler(e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed && _Vue === Vue) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  var isDef = function isDef(v) {
    return v !== undefined;
  };

  var registerInstance = function registerInstance(vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*  */

// $flow-disable-line
var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (undefined !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  // $flow-disable-line
  var pathMap = oldPathMap || Object.create(null);
  // $flow-disable-line
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (undefined !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (undefined !== 'production') {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (undefined !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
  if (undefined !== 'production') {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }
  return regex;
}

function normalizePath(path, parent, strict) {
  if (!strict) {
    path = path.replace(/\/$/, '');
  }
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

/*  */

function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (undefined !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;

  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (undefined !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      if (!record) {
        return _createRoute(null, location);
      }
      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (_typeof(location.params) !== 'object') {
        location.params = {};
      }

      if (currentRoute && _typeof(currentRoute.params) === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || (typeof redirect === 'undefined' ? 'undefined' : _typeof(redirect)) !== 'object') {
      if (undefined !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (undefined !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (undefined !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  // Fix for #1585 for Firefox
  window.history.replaceState({ key: getStateKey() }, '');
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (undefined !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);

    if (!shouldScroll) {
      return;
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition(shouldScroll, position);
      }).catch(function (err) {
        if (undefined !== 'production') {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

function scrollToPosition(shouldScroll, position) {
  var isObject = (typeof shouldScroll === 'undefined' ? 'undefined' : _typeof(shouldScroll)) === 'object';
  if (isObject && typeof shouldScroll.selector === 'string') {
    var el = document.querySelector(shouldScroll.selector);
    if (el) {
      var offset = shouldScroll.offset && _typeof(shouldScroll.offset) === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function step(index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          undefined !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var hasSymbol = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }if (called) {
      return;
    }
    called = true;
    return fn.apply(this, args);
  };
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function abort(err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function iterator(hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if ((typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function isValid() {
      return this$1.current === route;
    };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current;

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      var location = getLocation(this$1.base);
      if (this$1.current === START && location === initLocation) {
        return;
      }

      this$1.transitionTo(location, function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {
      var current = this$1.current;
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }
        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function getUrl(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return base + "#" + path;
}

function pushHash(path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash(path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (undefined !== 'production') {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: { configurable: true } };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  undefined !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function setupHashListener() {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.8.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

exports.default = VueRouter;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}

/**
 * Check if value is primitive.
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' ||
  // $flow-disable-line
  (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop(a, b, c) {}

/**
 * Always return false.
 */
var no = function no(a, b, c) {
  return false;
};

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: undefined !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: undefined !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = {}.watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check
var formatComponentName = noop;

if (undefined !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function repeat(str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  generateComponentTrace = function generateComponentTrace(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if (undefined !== 'production' && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode(text) {
  if (text === void 0) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data,
  // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (undefined !== 'production' && customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) {
        return;
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (undefined !== 'production' && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    undefined !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (undefined !== 'production' && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    undefined !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (undefined !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;

  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') {
      continue;
    }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      undefined !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    undefined !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }
  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (undefined !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && undefined !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (undefined !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (undefined !== 'production') {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
  var inject = options.inject;
  if (!inject) {
    return;
  }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
    }
  } else if (undefined !== 'production') {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (undefined !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (undefined !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (undefined !== 'production' &&
  // skip validation for weex recycle-list child component props
  !false) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (undefined !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i], vm);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  var haveExpectedTypes = expectedTypes.some(function (t) {
    return t;
  });
  if (!valid && haveExpectedTypes) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;

function assertType(value, type, vm) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    try {
      valid = value instanceof type;
    } catch (e) {
      warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
      valid = false;
    }
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

var functionTypeCheckRE = /^\s*function (\w+)/;

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }
  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  // check if we need to specify expected value
  if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value === 'undefined' ? 'undefined' : _typeof(value)) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + styleValue(value, expectedType);
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + styleValue(value, receivedType) + ".";
  }
  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable(value) {
  return EXPLICABLE_TYPES.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;
  while (len--) {
    args[len] = arguments[len];
  }return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}

/*  */

function handleError(err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (undefined !== 'production') {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function timerFunc() {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) {
      setTimeout(noop);
    }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
// PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function timerFunc() {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function timerFunc() {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function timerFunc() {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}

/*  */

var mark;
var measure;

if (undefined !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (undefined !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function warnReservedPrefix(target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);
      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      undefined !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (undefined !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (undefined !== 'production') {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') {
        continue;
      }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (undefined !== 'production') {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }
    return result;
  }
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}

/*  */

function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}

/*  */

function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function normalized() {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    var vnode = res && res[0];
    return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode) // #9658, #10391
    ) ? undefined : res;
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  ret._isVList = true;
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallbackRender, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if (undefined !== 'production' && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  } else {
    nodes = this.$slots[name] || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes);
  } else {
    return nodes;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
  return eventKeyCode === undefined;
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      undefined !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function loop(key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) {
        loop(key);
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree;
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      undefined !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}

/*  */

function resolveScopedSlots(fns, // see flow/vnode
res,
// the following are added in 2.6
hasDynamicKeys, contentHashKey) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    res.$key = contentHashKey;
  }
  return res;
}

/*  */

function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (undefined !== 'production' && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }
  return baseObj;
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}

/*  */

function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }
    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  });

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (undefined !== 'production') {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (undefined !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);

  return vnode;
}

function createComponentInstanceForVnode(
// we know it's MountedComponentVNode but flow doesn't
vnode,
// activeInstance in lifecycle state
parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function merged(a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged;
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    undefined !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // warn against non-primitive key
  if (undefined !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (undefined !== 'production' && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
        warn("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
      }
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }
    if (isDef(data)) {
      registerDeepBindings(data);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (undefined !== 'production') {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (undefined !== 'production' && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (undefined !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };
}

/*  */

function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;owner.$on('hook:destroyed', function () {
      return remove(owners, owner);
    });

    var forceRender = function forceRender(renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
      undefined !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(undefined !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (!fn) {
      vm._events[event] = null;
      return vm;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (undefined !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm;
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (undefined !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (undefined !== 'production' && config.performance && mark) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (undefined !== 'production') {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (undefined !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (undefined !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function getNow() {
      return performance.now();
    };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (undefined !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if (undefined !== 'production' && !config.async) {
        flushSchedulerQueue();
        return;
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = undefined !== 'production' ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
      undefined !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        var info = "callback for watcher \"" + this.expression + "\"";
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (undefined !== 'production') {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    undefined !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (undefined !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }
    if (props && hasOwn(props, key)) {
      undefined !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (undefined !== 'production' && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (undefined !== 'production') {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn("The computed property \"" + key + "\" is already defined as a method.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (undefined !== 'production' && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (undefined !== 'production') {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + _typeof(methods[key]) + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }
      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (undefined !== 'production') {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      var info = "callback for immediate watcher \"" + watcher.expression + "\"";
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (undefined !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (undefined !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (undefined !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = latest[key];
    }
  }
  return modified;
}

function Vue(options) {
  if (undefined !== 'production' && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (undefined !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (undefined !== 'production' && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var entry = cache[key];
    if (entry) {
      var name = entry.name;
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var entry = cache[key];
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  methods: {
    cacheVNode: function cacheVNode() {
      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var vnodeToCache = ref.vnodeToCache;
      var keyToCache = ref.keyToCache;
      if (vnodeToCache) {
        var tag = vnodeToCache.tag;
        var componentInstance = vnodeToCache.componentInstance;
        var componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: getComponentName(componentOptions),
          tag: tag,
          componentInstance: componentInstance
        };
        keys.push(keyToCache);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
        this.vnodeToCache = null;
      }
    }
  },

  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted() {
    var this$1 = this;

    this.cacheVNode();
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },

  updated: function updated() {
    this.cacheVNode();
  },

  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
      // not included
      include && (!name || !matches(include, name)) ||
      // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        // delay setting the cache until update
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }

      vnode.data.keepAlive = true;
    }
    return vnode || slot && slot[0];
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (undefined !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.14';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function convertEnumeratedValue(key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false'
  // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */
  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }
      res += stringified;
    }
  }
  return res;
}

function stringifyObject(value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }
      res += key;
    }
  }
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function isPreTag(tag) {
  return tag === 'pre';
};

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      undefined !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (undefined !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (undefined !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (undefined !== 'production') {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (undefined !== 'production') {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (undefined !== 'production') {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    // assert node match
    if (undefined !== 'production') {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (undefined !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (undefined !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (undefined !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function blocker(e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}

/*  */

/* eslint-disable no-unused-vars */
function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (undefined !== 'production' && warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr(el, name, removeFromMap) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;
  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];
    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }
    if (range.end != null) {
      item.end = range.end;
    }
  }
  return item;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var res = parseModel(value);
  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (undefined !== 'production') {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (undefined !== 'production') {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  if (undefined !== 'production') {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
      // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget ||
      // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp ||
      // bail for environments that have buggy event.timeStamp implementations
      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
      // #9681 QtWebEngine event.timeStamp is negative value
      e.timeStamp <= 0 ||
      // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }
  target$1.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
    // skip the update if old and new VDOM state is the same.
    // `value` is handled separately because the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This  #4521 by skipping the unnecessary `checked` update.
    cur !== oldProps[key]) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}
  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (undefined !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (undefined !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    undefined !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function isNotTextNode(c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function isVShowDirective(d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (undefined !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (undefined !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
    // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount() {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (undefined !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (undefined !== 'production' && undefined !== 'test') {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }
    if (undefined !== 'production' && undefined !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (undefined !== 'production' && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (undefined !== 'production') {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/**
 * Not type-checking this file because it's mostly vendor code.
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being passed as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }
          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (undefined !== 'production' && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", { start: index + html.length });
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
      if (undefined !== 'production' && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (undefined !== 'production' && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", { start: stack[i].start, end: stack[i].end });
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;

var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

var slotRE = /^v-slot(:|$)|^#/;

var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /[ \f\t\r\n]+/g;

var invalidAttributeRE = /[\s"'<>\/=]/;

var decodeHTMLCached = cached(he.decode);

var emptySlotScopeToken = "_empty_";

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;
  maybeComponent = function maybeComponent(el) {
    return !!(el.component || el.attrsMap[':is'] || el.attrsMap['v-bind:is'] || !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));
  };
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);
    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    }
    // tree management
    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (undefined !== 'production') {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (undefined !== 'production') {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", { start: element.start });
      }
    }
    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }
        currentParent.children.push(element);
        element.parent = currentParent;
      }
    }

    // final children cleanup
    // filter out scoped slots
    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    });
    // remove trailing whitespace node again
    trimEndingWhitespace(element);

    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;
      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', { start: el.start });
    }
    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (undefined !== 'production') {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }
        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        undefined !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', { start: element.start });
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        if (undefined !== 'production') {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1];
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      if (undefined !== 'production' && options.outputSourceRange) {
        element.end = end$1;
      }
      closeElement(element);
    },

    chars: function chars(text, start, end) {
      if (!currentParent) {
        if (undefined !== 'production') {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', { start: start });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", { start: start });
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }
      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }
        var res;
        var child;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }
        if (child) {
          if (undefined !== 'production' && options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anything as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };
        if (undefined !== 'production' && options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }
        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;
  if (len) {
    var attrs = el.attrs = new Array(len);
    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };
      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;

  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (undefined !== 'production') {
      if (el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }
      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;
        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else if (undefined !== 'production') {
      warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) {
    return;
  }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (undefined !== 'production') {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (undefined !== 'production' && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent(el) {
  var slotScope;
  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */
    if (undefined !== 'production' && slotScope) {
      warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if (undefined !== 'production' && el.attrsMap['v-for']) {
      warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }

  // 2.6 v-slot syntax
  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding) {
        if (undefined !== 'production') {
          if (el.slotTarget || el.slotScope) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }
          if (el.parent && !maybeComponent(el.parent)) {
            warn$2("<template v-slot> can only appear at the root level inside " + "the receiving component", el);
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding$1) {
        if (undefined !== 'production') {
          if (!maybeComponent(el)) {
            warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
          }
          if (el.slotScope || el.slotTarget) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }
          if (el.scopedSlots) {
            warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        }
        // add the component's children to its default slot
        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
        // remove children as they are returned from scopedSlots now
        el.children = [];
        // mark el non-plain so data gets generated
        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');
  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (undefined !== 'production') {
      warn$2("v-slot shorthand syntax requires a slot name.", binding);
    }
  }
  return dynamicArgRE.test(name)
  // dynamic [name]
  ? { name: name.slice(1, -1), dynamic: true
    // static name
  } : { name: "\"" + name + "\"", dynamic: false };
}

// handle <slot/> outlets
function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (undefined !== 'production' && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name.replace(dirRE, ''));
      // support .foo shorthand syntax for the .prop modifier
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        if (undefined !== 'production' && value.trim().length === 0) {
          warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }
        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");
            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);
              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }
        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
        if (undefined !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (undefined !== 'production') {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]);
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (undefined !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }
    _el = _el.parent;
  }
}

/*  */

function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return;
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};

var modules$1 = [klass$1, style$1, model$1];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function genGuard(condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";
  for (var name in events) {
    var handlerCode = genHandler(events[name]);
    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }
  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";
  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }
    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? "return " + handler.value + ".apply(null, arguments)" : isFunctionExpression ? "return (" + handler.value + ").apply(null, arguments)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}

/*  */

function on(el, dir) {
  if (undefined !== 'production' && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };
  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  // fix #11483, Root level <script> tags should not be rendered.
  var code = ast ? ast.tag === 'script' ? 'null' : genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;
      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el, state) {
  el.staticProcessed = true;
  // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.
  var originalPreState = state.pre;
  if (el.pre) {
    state.pre = el.pre;
  }
  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
}

// v-once
function genOnce(el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      undefined !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }
    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (undefined !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  }
  // DOM props
  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.
  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  }
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];
  if (undefined !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {
    state.warn('Inline-template components must have exactly one child element.', { start: el.start });
  }
  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  });

  // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.
  var needsKey = !!el.if;

  // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.
  if (!needsForceUpdate) {
    var parent = el.parent;
    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {
        needsForceUpdate = true;
        break;
      }
      if (parent.if) {
        needsKey = true;
      }
      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',');

  return "scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? ",null,false," + hash(generatedSlots) : "") + ")";
}

function hash(str) {
  var hash = 5381;
  var i = str.length;
  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }
  return hash >>> 0;
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }
    return el.children.some(containsSlotChild);
  }
  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];
  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }
  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }
  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}";
  // reverse proxy v-slot without scope on this.$slots
  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }
    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children, maybeComponent) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ",function(){return " + children + "}" : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);
    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }
  staticProps = "{" + staticProps.slice(0, -1) + "}";
  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          var range = node.rawAttrsMap[name];
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, name + "=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stripped = exp.replace(stripStringRE, '');
  var keywordMatch = stripped.match(unaryOperatorsRE);
  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }
  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}

function checkFunctionParameterExpression(exp, text, warn, range) {
  try {
    new Function(exp, '');
  } catch (e) {
    warn("invalid function parameter expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
  }
}

/*  */

var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;

  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];
  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }
        res.push("" + (j + 1) + repeat$1(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;
        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join('\n');
}

function repeat$1(str, n) {
  var result = '';
  if (n > 0) {
    while (true) {
      // eslint-disable-line
      if (n & 1) {
        result += str;
      }
      n >>>= 1;
      if (n <= 0) {
        break;
      }
      str += str;
    }
  }
  return result;
}

/*  */

function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);

  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (undefined !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (cache[key]) {
      return cache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (undefined !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (undefined !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return cache[key] = res;
  };
}

/*  */

function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function warn(msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (undefined !== 'production' && options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function warn(msg, range, tip) {
            var data = { msg: msg };
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }
            (tip ? tips : errors).push(data);
          };
        }
        // merge custom modules
        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;

      var compiled = baseCompile(template.trim(), finalOptions);
      if (undefined !== 'production') {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    undefined !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (undefined !== 'production' && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (undefined !== 'production') {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (undefined !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: undefined !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (undefined !== 'production' && config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;

exports.default = Vue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(13).setImmediate))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(5);

// Load library
H5P.Feedback = __webpack_require__(4).default;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _striptags = __webpack_require__(12);

var _striptags2 = _interopRequireDefault(_striptags);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var InteractionType = {
  FILL_IN: 'fill-in',
  LIKERT: 'likert'
};

var Type = {
  INTERACTION: 'http://adlnet.gov/expapi/activities/cmi.interaction'
};

var XAPIBuilder = function () {
  function XAPIBuilder(question) {
    _classCallCheck(this, XAPIBuilder);
  }

  /**
   * Creates an answered xAPI event with with the score
   *
   * @param {XAPIEvent} event
   * @param {string} description
   * @param {string} score
   * @param {object[]} scale
   * @return {XAPIEvent}
   */


  _createClass(XAPIBuilder, [{
    key: 'createLikertEvent',
    value: function createLikertEvent(event, description, score, scale) {
      // prepare question
      var definition = event.getVerifiedStatementValue(['object', 'definition']);
      definition.description = this.wrapAsTranslation(description);
      definition.type = Type.INTERACTION;
      definition.interactionType = InteractionType.LIKERT;
      definition.correctResponsesPattern = [score];
      definition.scale = scale;

      // prepare answer

      return event;
    }

    /**
     * Creates an answered xAPI event with with the response text
     *
     * @param {XAPIEvent} event
     * @param {string} description
     * @param {string} responseText
     * @return {XAPIEvent}
     */

  }, {
    key: 'createTextEvent',
    value: function createTextEvent(event, description, responseText) {
      // prepare question
      var definition = event.getVerifiedStatementValue(['object', 'definition']);
      definition.description = this.wrapAsTranslation(description);
      definition.type = Type.INTERACTION;
      definition.interactionType = InteractionType.FILL_IN;
      definition.correctResponsesPattern = [responseText];

      return event;
    }

    /*
    addResponseToXAPI (event) {
      const isCorrect = answerGroup.isCorrect();
      event.setScoredResult(isCorrect ? MAX_SCORE : 0, MAX_SCORE, self, true, isCorrect);
      event.data.statement.result.response = (isCorrect ? getCorrectAnswer() : getWrongAnswer());
    };*/

    /**
     * Wraps a string as translation for en-US
     *
     * @param {string} str
     * @return {object}
     */

  }, {
    key: 'wrapAsTranslation',
    value: function wrapAsTranslation(str) {
      return { 'en-US': (0, _striptags2.default)(str) };
    }
  }]);

  return XAPIBuilder;
}();

exports.default = XAPIBuilder;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)(undefined);
// imports


// module
exports.push([module.i, "\n.feedback-score-input {\n  margin-top: -1em;\n  float: right;\n}\n.feedback-score-input li {\n    display: inline-block;\n}\n.feedback-score-input [role=\"button\"] {\n    cursor: pointer;\n    margin: 0 1em 2em 1em;\n    height: 50px;\n    width: 50px;\n    outline: none;\n    position: relative;\n}\n.feedback-score-input [role=\"button\"]:focus .feedback-score-4 .face, .feedback-score-input [role=\"button\"]:hover .feedback-score-4 .face {\n      fill: #63a96d;\n}\n.feedback-score-input [role=\"button\"]:focus .feedback-score-3 .face, .feedback-score-input [role=\"button\"]:hover .feedback-score-3 .face {\n      fill: #a3aa66;\n}\n.feedback-score-input [role=\"button\"]:focus .feedback-score-2 .face, .feedback-score-input [role=\"button\"]:hover .feedback-score-2 .face {\n      fill: #e38743;\n}\n.feedback-score-input [role=\"button\"]:focus .feedback-score-1 .face, .feedback-score-input [role=\"button\"]:hover .feedback-score-1 .face {\n      fill: #c85e5f;\n}\n.feedback-score-input [role=\"button\"]:focus .feedback-score-title, .feedback-score-input [role=\"button\"]:hover .feedback-score-title {\n      display: block;\n}\n.feedback-score-input [role=\"button\"]:focus .face, .feedback-score-input [role=\"button\"]:hover .face {\n      -webkit-transform: translateY(-10px);\n      transform: translateY(-10px);\n}\n.feedback-score-input [role=\"button\"]:focus .shadow, .feedback-score-input [role=\"button\"]:hover .shadow {\n      transform: scaleX(0.7) translateX(7.5px);\n}\n.feedback-score-input .feedback-score-title {\n    position: absolute;\n    bottom: -2em;\n    left: 0;\n    right: 0;\n    font-weight: 400;\n    margin: auto;\n    white-space: nowrap;\n    display: none;\n}\n.feedback-score-input .face-container {\n    overflow: visible;\n}\n.feedback-score-input .face {\n    -webkit-transition: all .2s ease-in;\n    transition: all .2s ease-in;\n    fill: #a4c3ef;\n}\n.feedback-score-input .shadow {\n    -webkit-transition: all .2s ease-in;\n    transition: all .2s ease-in;\n    fill: #B9B9B9;\n}\n", ""]);

// exports


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)(undefined);
// imports


// module
exports.push([module.i, "\n.feedback-text-input .from-score-input {\n  margin-bottom: 2em;\n}\n.feedback-text-input .feedback-score {\n  display: inline-block;\n  width: 2.5em;\n  height: 2.5em;\n  margin-right: 1em;\n  margin-bottom: -1em;\n}\n.feedback-text-input .feedback-score-title {\n  margin-right: 1em;\n}\n", ""]);

// exports


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = "<svg version=\"1.1\" id=\"f1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 34.2 37.8\" style=\"enable-background:new 0 0 34.2 37.8;\" xml:space=\"preserve\" class=\"face-container\"><ellipse id=\"shadow-1\" class=\"shadow\" cx=\"17.3\" cy=\"37.2\" rx=\"9\" ry=\"0.6\"></ellipse><path id=\"face-1\" class=\"face\" d=\"M17.1,34.3C7.6,34.3,0,26.6,0,17.1C0,7.7,7.6,0,17.1,0s17.1,7.7,17.1,17.1 C34.3,26.6,26.6,34.3,17.1,34.3z M17.1,2.9C9.2,2.9,2.8,9.3,2.8,17.1c0,7.9,6.4,14.3,14.3,14.3S31.4,25,31.4,17.1 C31.4,9.3,25,2.9,17.1,2.9z M11.4,14.3c-1.6,0-2.9-1.3-2.9-2.9s1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9S13,14.3,11.4,14.3z M22.8,14.3 c-1.6,0-2.9-1.3-2.9-2.9s1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9S24.4,14.3,22.8,14.3z M24.6,26.1c-0.8,0.2-1.6-0.2-1.8-0.9 c-0.7-2.4-2.9-4-5.4-4s-4.7,1.6-5.4,4c-0.2,0.8-1,1.2-1.8,0.9c-0.8-0.2-1.2-1-0.9-1.8c1.1-3.6,4.4-6,8.2-6s7.1,2.4,8.2,6 C25.8,25.1,25.4,25.8,24.6,26.1z\"></path></svg>"

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = "<svg version=\"1.1\" id=\"f2\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 34.2 37.8\" style=\"enable-background:new 0 0 34.2 37.8;\" xml:space=\"preserve\" class=\"face-container\"><ellipse id=\"shadow-2\" class=\"shadow\" cx=\"17.3\" cy=\"37.2\" rx=\"9\" ry=\"0.6\"></ellipse><path id=\"face-2\" class=\"face\" d=\"M17.1,34.3C7.6,34.3,0,26.6,0,17.1C0,7.7,7.6,0,17.1,0s17.1,7.7,17.1,17.1 C34.3,26.6,26.6,34.3,17.1,34.3z M17.1,2.9C9.2,2.9,2.8,9.3,2.8,17.1c0,7.9,6.4,14.3,14.3,14.3S31.4,25,31.4,17.1 C31.4,9.3,25,2.9,17.1,2.9z M11.4,14.3c-1.6,0-2.9-1.3-2.9-2.9s1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9S13,14.3,11.4,14.3z M22.8,14.3 c-1.6,0-2.9-1.3-2.9-2.9s1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9S24.4,14.3,22.8,14.3z M23.2,20.6H11.7c-1.1,0-2,0.9-2,2c0,1.1,0.9,2,2,2 h11.5c1.1,0,2-0.9,2-2C25.2,21.5,24.3,20.6,23.2,20.6z\"></path></svg>"

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = "<svg version=\"1.1\" id=\"f3\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 34.2 37.8\" style=\"enable-background:new 0 0 34.2 37.8;\" xml:space=\"preserve\" class=\"face-container\"><ellipse id=\"shadow-3\" class=\"shadow\" cx=\"17.3\" cy=\"37.2\" rx=\"9\" ry=\"0.6\"></ellipse><path id=\"face-3\" class=\"face\" d=\"M17.1,34.3C7.6,34.3,0,26.6,0,17.1C0,7.7,7.6,0,17.1,0s17.1,7.7,17.1,17.1 C34.3,26.6,26.6,34.3,17.1,34.3z M17.1,2.9C9.2,2.9,2.8,9.3,2.8,17.1c0,7.9,6.4,14.3,14.3,14.3S31.4,25,31.4,17.1 C31.4,9.3,25,2.9,17.1,2.9z M11.4,14.3c-1.6,0-2.9-1.3-2.9-2.9s1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9S13,14.3,11.4,14.3z M17.1,27.1 c-3.8,0-7.1-2.4-8.2-6c-0.2-0.8,0.2-1.5,0.9-1.8c0.7-0.2,1.5,0.2,1.8,0.9c0.7,2.4,2.9,4,5.4,4s4.7-1.6,5.4-4c0.2-0.8,1-1.2,1.8-0.9 c0.7,0.2,1.2,1,0.9,1.8C24.2,24.7,20.9,27.1,17.1,27.1z M22.8,14.3c-1.6,0-2.9-1.3-2.9-2.9s1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9 S24.4,14.3,22.8,14.3z\"></path></svg>"

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = "<svg version=\"1.1\" id=\"f4\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 34.2 37.8\" style=\"enable-background:new 0 0 34.2 37.8;\" xml:space=\"preserve\" class=\"face-container\"><ellipse id=\"shadow-4\" class=\"shadow\" cx=\"17.3\" cy=\"37.2\" rx=\"9\" ry=\"0.6\"></ellipse><path id=\"face-4\" class=\"face\" d=\"M17.1,34.3C7.6,34.3,0,26.6,0,17.1C0,7.7,7.6,0,17.1,0s17.1,7.7,17.1,17.1 C34.3,26.6,26.6,34.3,17.1,34.3z M17.1,2.9C9.2,2.9,2.8,9.3,2.8,17.1c0,7.9,6.4,14.3,14.3,14.3S31.4,25,31.4,17.1 C31.4,9.3,25,2.9,17.1,2.9z M11.4,14.3c-1.6,0-2.9-1.3-2.9-2.9s1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9S13,14.3,11.4,14.3z M22.8,14.3 c-1.6,0-2.9-1.3-2.9-2.9s1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9S24.4,14.3,22.8,14.3z M25.3,19.3c-0.2-0.1-0.5-0.1-0.7,0H10.3 c-0.2,0-0.5,0-0.7,0c-0.8,0.2-1.2,1-0.9,1.8c1.1,3.6,4.1,7.2,8.7,7.2c4.2,0,7.8-3.6,8.9-7.2C26.5,20.3,26.1,19.5,25.3,19.3z M17.3,25.4c-1.8,0-3.7-1.1-4.9-3.1h10C21.1,24.2,19.1,25.4,17.3,25.4z\"></path></svg>"

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(14),
  /* template */
  __webpack_require__(32),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "E:\\Stc\\Curriki\\h5p_repo\\h5p-feedback\\src\\scripts\\views\\Final.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] Final.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5c2bb111", Component.options)
  } else {
    hotAPI.reload("data-v-5c2bb111", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(34)

var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(15),
  /* template */
  __webpack_require__(31),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "E:\\Stc\\Curriki\\h5p_repo\\h5p-feedback\\src\\scripts\\views\\ScoreInput.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] ScoreInput.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4903dccd", Component.options)
  } else {
    hotAPI.reload("data-v-4903dccd", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(35)

var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(16),
  /* template */
  __webpack_require__(33),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "E:\\Stc\\Curriki\\h5p_repo\\h5p-feedback\\src\\scripts\\views\\TextInput.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] TextInput.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6315a138", Component.options)
  } else {
    hotAPI.reload("data-v-6315a138", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "h5p-feedback-score",
    attrs: {
      "role": "region"
    }
  }, [_c('h3', {
    staticClass: "feedback-title",
    domProps: {
      "innerHTML": _vm._s(_vm.message)
    }
  }), _c('ul', {
    staticClass: "feedback-score-input"
  }, _vm._l((_vm.alternatives), function(alternative) {
    return _c('li', [_c('div', {
      attrs: {
        "role": "button",
        "tabindex": "0"
      },
      on: {
        "click": function($event) {
          return _vm.sendScore(alternative)
        }
      }
    }, [_c('div', {
      class: alternative.cls,
      domProps: {
        "innerHTML": _vm._s(alternative.icon)
      }
    }), _c('div', {
      staticClass: "feedback-score-title"
    }, [_vm._v(_vm._s(alternative.title))])])])
  }), 0)])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-4903dccd", module.exports)
  }
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "h5p-feedback-final",
    attrs: {
      "role": "region"
    },
    domProps: {
      "innerHTML": _vm._s(_vm.finishedText)
    }
  })
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-5c2bb111", module.exports)
  }
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "feedback-text-input",
    attrs: {
      "role": "region"
    }
  }, [_c('div', {
    staticClass: "from-score-input"
  }, [_c('span', {
    staticClass: "feedback-score",
    class: _vm.alternative.cls
  }), _c('span', {
    staticClass: "feedback-score-title"
  }, [_vm._v(_vm._s(this.alternative.title))]), _c('router-link', {
    attrs: {
      "to": "/score-input"
    }
  }, [_vm._v("Change")])], 1), _c('div', {
    domProps: {
      "innerHTML": _vm._s(_vm.labelTextInput)
    }
  }), _c('textarea', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.text),
      expression: "text"
    }],
    attrs: {
      "rows": "4",
      "placeholder": "Your Feedback"
    },
    domProps: {
      "value": (_vm.text)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.text = $event.target.value
      }
    }
  }), _c('button', {
    staticClass: "button button-primary",
    attrs: {
      "disabled": _vm.text.length < 1
    },
    on: {
      "click": function($event) {
        return _vm.sendText(_vm.text)
      }
    }
  }, [_vm._v("Send")])])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-6315a138", module.exports)
  }
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(22);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(3)("291301c4", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"id\":\"data-v-4903dccd\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/lib/loader.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./ScoreInput.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"id\":\"data-v-4903dccd\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/lib/loader.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./ScoreInput.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(23);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(3)("0e68e2a2", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"id\":\"data-v-6315a138\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/lib/loader.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./TextInput.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"id\":\"data-v-6315a138\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/lib/loader.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./TextInput.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjBiYjcwMjk0NjM4OGNjOGFkYzIiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvYXBwLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbWFpbi5zY3NzPzM3ZmMiLCJ3ZWJwYWNrOi8vLy4vfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJpcHRhZ3Mvc3JjL3N0cmlwdGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vL0ZpbmFsLnZ1ZSIsIndlYnBhY2s6Ly8vU2NvcmVJbnB1dC52dWUiLCJ3ZWJwYWNrOi8vL1RleHRJbnB1dC52dWUiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWUvZGlzdC92dWUuZXNtLmpzIiwid2VicGFjazovLy8uL3NyYy9lbnRyaWVzL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY29tcG9uZW50cy94YXBpLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3ZpZXdzL1Njb3JlSW5wdXQudnVlPzljYmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvVGV4dElucHV0LnZ1ZT8zYWEwIiwid2VicGFjazovLy8uL3NyYy9pbWFnZXMvZmFjZTEuc3ZnIiwid2VicGFjazovLy8uL3NyYy9pbWFnZXMvZmFjZTIuc3ZnIiwid2VicGFjazovLy8uL3NyYy9pbWFnZXMvZmFjZTMuc3ZnIiwid2VicGFjazovLy8uL3NyYy9pbWFnZXMvZmFjZTQuc3ZnIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3ZpZXdzL0ZpbmFsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy92aWV3cy9TY29yZUlucHV0LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy92aWV3cy9UZXh0SW5wdXQudnVlIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3ZpZXdzL1Njb3JlSW5wdXQudnVlPzU4MWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvRmluYWwudnVlPzFlODMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvVGV4dElucHV0LnZ1ZT81YzU3Iiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3ZpZXdzL1Njb3JlSW5wdXQudnVlPzU0NGEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvVGV4dElucHV0LnZ1ZT8wZDBlIl0sIm5hbWVzIjpbImciLCJGdW5jdGlvbiIsImV2YWwiLCJlIiwid2luZG93IiwibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJwdXNoIiwiY3NzTWFwcGluZyIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJjb25jYXQiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJCdWZmZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsIlZ1ZSIsInVzZSIsIlJvdXRlciIsIkZlZWRiYWNrIiwiY29uZmlnIiwiY29udGVudElkIiwiY29udGVudERhdGEiLCJ4YXBpIiwiWEFQSUJ1aWxkZXIiLCJzdGF0ZSIsInByZXZpb3VzU3RhdGUiLCJhbHRlcm5hdGl2ZXMiLCJ0aXRsZSIsImwxMG4iLCJzY2FsZVZlcnlTYXRpc2ZpZWQiLCJjbHMiLCJzY29yZSIsImljb24iLCJGYWNlNCIsInNjYWxlU2F0aXNmaWVkIiwiRmFjZTMiLCJzY2FsZU5ldXRyYWwiLCJGYWNlMiIsInNjYWxlVW5zYXRpc2ZpZWQiLCJGYWNlMSIsIlRleHRJbnB1dCIsInRleHQiLCJsYWJlbFRleHRJbnB1dCIsInJvdXRlciIsIm1vZGUiLCJyb3V0ZXMiLCJwYXRoIiwiY29tcG9uZW50IiwiU2NvcmVJbnB1dCIsInByb3BzIiwibWVzc2FnZSIsImxhYmVsU2NvcmVJbnB1dCIsIkZpbmFsIiwiZmluaXNoZWRUZXh0IiwicmVkaXJlY3QiLCJiZWZvcmVFYWNoIiwidG8iLCJmcm9tIiwibmV4dCIsInRyaWdnZXIiLCJ2aWV3TW9kZWwiLCJhcHAiLCIkb24iLCJyZXNwb25zZVRleHQiLCJzY2FsZSIsImFsdGVybmF0aXZlZVRvU2NhbGUiLCJldmVudCIsImNyZWF0ZVhBUElFdmVudFRlbXBsYXRlIiwiY3JlYXRlTGlrZXJ0RXZlbnQiLCJjcmVhdGVUZXh0RXZlbnQiLCJhdHRhY2giLCIkd3JhcHBlciIsImdldCIsImFwcGVuZENoaWxkIiwiY3JlYXRlUm9vdEVsZW1lbnQiLCIkbW91bnQiLCJnZXRDdXJyZW50U3RhdGUiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiaW5uZXJIVE1MIiwiYWx0ZXJuYXRpdmUiLCJkZXNjcmlwdGlvbiIsIndyYXBBc1RyYW5zbGF0aW9uIiwiSDVQIiwiRXZlbnREaXNwYXRjaGVyIiwiYnl0ZUxlbmd0aCIsInRvQnl0ZUFycmF5IiwiZnJvbUJ5dGVBcnJheSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJBcnJheSIsImNvZGUiLCJsZW4iLCJjaGFyQ29kZUF0IiwiZ2V0TGVucyIsImI2NCIsIkVycm9yIiwidmFsaWRMZW4iLCJpbmRleE9mIiwicGxhY2VIb2xkZXJzTGVuIiwibGVucyIsIl9ieXRlTGVuZ3RoIiwidG1wIiwiYXJyIiwiY3VyQnl0ZSIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsImVuZCIsIm91dHB1dCIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsInJlcXVpcmUiLCJpZWVlNzU0IiwiaXNBcnJheSIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJnbG9iYWwiLCJ1bmRlZmluZWQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImtNYXhMZW5ndGgiLCJfX3Byb3RvX18iLCJwcm90b3R5cGUiLCJmb28iLCJzdWJhcnJheSIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJSYW5nZUVycm9yIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwicG9vbFNpemUiLCJfYXVnbWVudCIsInZhbHVlIiwiVHlwZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsIlN5bWJvbCIsInNwZWNpZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJmcm9tQXJyYXlMaWtlIiwiYXJyYXkiLCJieXRlT2Zmc2V0Iiwib2JqIiwiaXNCdWZmZXIiLCJjb3B5IiwiYnVmZmVyIiwiaXNuYW4iLCJ0eXBlIiwiYiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwieCIsInkiLCJNYXRoIiwibWluIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJwb3MiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwibiIsIm0iLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJhcmd1bWVudHMiLCJhcHBseSIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJtYXgiLCJtYXRjaCIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImRpciIsImlzTmFOIiwiYXJyYXlJbmRleE9mIiwiY2FsbCIsImxhc3RJbmRleE9mIiwiaW5kZXhTaXplIiwiYXJyTGVuZ3RoIiwidmFsTGVuZ3RoIiwicmVhZCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImoiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwib2Zmc2V0IiwiTnVtYmVyIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VkIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwidG9KU09OIiwiX2FyciIsInJlcyIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsImZsb29yIiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsInNldCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwicmVwbGFjZSIsInRyaW0iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImMiLCJoaSIsImxvIiwic3JjIiwiZHN0IiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJkIiwicyIsIk5hTiIsInJ0IiwiYWJzIiwibG9nIiwiTE4yIiwicHJvY2VzcyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkl0ZW0iLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJzZXRJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwiY2FsbGJhY2siLCJ0YXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJoYW5kbGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsIm9ubWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsInJhbmRvbSIsIm9uR2xvYmFsTWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50Iiwic2NyaXB0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVtb3ZlQ2hpbGQiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJnZXRQcm90b3R5cGVPZiIsInNlbGYiLCJub25OYXRpdmUiLCJTVEFURV9QTEFJTlRFWFQiLCJTVEFURV9IVE1MIiwiU1RBVEVfQ09NTUVOVCIsIkFMTE9XRURfVEFHU19SRUdFWCIsIk5PUk1BTElaRV9UQUdfUkVHRVgiLCJzdHJpcHRhZ3MiLCJhbGxvd2FibGVfdGFncyIsInRhZ19yZXBsYWNlbWVudCIsImNvbnRleHQiLCJpbml0X2NvbnRleHQiLCJzdHJpcHRhZ3NfaW50ZXJuYWwiLCJpbml0X3N0cmlwdGFnc19zdHJlYW0iLCJzdHJpcHRhZ3Nfc3RyZWFtIiwiaW5pdF9zdHJlYW1pbmdfbW9kZSIsInBhcnNlX2FsbG93YWJsZV90YWdzIiwidGFnX2J1ZmZlciIsImRlcHRoIiwiaW5fcXVvdGVfY2hhciIsImlkeCIsImNoYXIiLCJoYXMiLCJub3JtYWxpemVfdGFnIiwidGFnX3NldCIsIlNldCIsImV4ZWMiLCJhZGQiLCJpdGVyYXRvciIsImZvckVhY2giLCJkZWZpbmUiLCJtb2R1bGVfZmFjdG9yeSIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwid2FybiIsImNvbnNvbGUiLCJpc0Vycm9yIiwiZXJyIiwiVmlldyIsImZ1bmN0aW9uYWwiLCJkZWZhdWx0IiwicmVuZGVyIiwiXyIsImNoaWxkcmVuIiwicGFyZW50Iiwicm91dGVyVmlldyIsImgiLCIkY3JlYXRlRWxlbWVudCIsInJvdXRlIiwiJHJvdXRlIiwiY2FjaGUiLCJfcm91dGVyVmlld0NhY2hlIiwiaW5hY3RpdmUiLCJfcm91dGVyUm9vdCIsIiR2bm9kZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJtYXRjaGVkIiwiY29tcG9uZW50cyIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsInZtIiwiY3VycmVudCIsImluc3RhbmNlcyIsImhvb2siLCJwcmVwYXRjaCIsInZub2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwcm9wc1RvUGFzcyIsInJlc29sdmVQcm9wcyIsImV4dGVuZCIsImF0dHJzIiwia2V5IiwicGFyYW1zIiwiZW5jb2RlUmVzZXJ2ZVJFIiwiZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyIiwiY29tbWFSRSIsImVuY29kZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlc29sdmVRdWVyeSIsInF1ZXJ5IiwiZXh0cmFRdWVyeSIsIl9wYXJzZVF1ZXJ5IiwicGFyc2UiLCJwYXJzZVF1ZXJ5IiwicGFyc2VkUXVlcnkiLCJzcGxpdCIsInBhcmFtIiwic2hpZnQiLCJzdHJpbmdpZnlRdWVyeSIsImtleXMiLCJyZXN1bHQiLCJ2YWwyIiwiZmlsdGVyIiwidHJhaWxpbmdTbGFzaFJFIiwiY3JlYXRlUm91dGUiLCJyZWNvcmQiLCJsb2NhdGlvbiIsInJlZGlyZWN0ZWRGcm9tIiwic3RyaW5naWZ5UXVlcnkkJDEiLCJvcHRpb25zIiwiY2xvbmUiLCJtZXRhIiwiaGFzaCIsImZ1bGxQYXRoIiwiZ2V0RnVsbFBhdGgiLCJmb3JtYXRNYXRjaCIsImZyZWV6ZSIsIlNUQVJUIiwidW5zaGlmdCIsIl9zdHJpbmdpZnlRdWVyeSIsImlzU2FtZVJvdXRlIiwiaXNPYmplY3RFcXVhbCIsImFLZXlzIiwiYktleXMiLCJldmVyeSIsImFWYWwiLCJiVmFsIiwiaXNJbmNsdWRlZFJvdXRlIiwicXVlcnlJbmNsdWRlcyIsInRvVHlwZXMiLCJldmVudFR5cGVzIiwiTGluayIsInJlcXVpcmVkIiwidGFnIiwiZXhhY3QiLCJCb29sZWFuIiwiYXBwZW5kIiwiYWN0aXZlQ2xhc3MiLCJleGFjdEFjdGl2ZUNsYXNzIiwidGhpcyQxIiwiJHJvdXRlciIsInJlc29sdmUiLCJocmVmIiwiY2xhc3NlcyIsImdsb2JhbEFjdGl2ZUNsYXNzIiwibGlua0FjdGl2ZUNsYXNzIiwiZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyIsImxpbmtFeGFjdEFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3NGYWxsYmFjayIsImV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayIsImNvbXBhcmVUYXJnZXQiLCJoYW5kbGVyIiwiZ3VhcmRFdmVudCIsImNsaWNrIiwiY2xhc3MiLCJmaW5kQW5jaG9yIiwiJHNsb3RzIiwiaXNTdGF0aWMiLCJfVnVlIiwidXRpbCIsImFEYXRhIiwiYUF0dHJzIiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJidXR0b24iLCJjdXJyZW50VGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsInByZXZlbnREZWZhdWx0IiwiY2hpbGQiLCJpbnN0YWxsIiwiaW5zdGFsbGVkIiwiaXNEZWYiLCJ2IiwicmVnaXN0ZXJJbnN0YW5jZSIsImNhbGxWYWwiLCIkb3B0aW9ucyIsIl9wYXJlbnRWbm9kZSIsIm1peGluIiwiYmVmb3JlQ3JlYXRlIiwiX3JvdXRlciIsImluaXQiLCJkZWZpbmVSZWFjdGl2ZSIsImhpc3RvcnkiLCJkZXN0cm95ZWQiLCJfcm91dGUiLCJzdHJhdHMiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJiZWZvcmVSb3V0ZUVudGVyIiwiYmVmb3JlUm91dGVMZWF2ZSIsImJlZm9yZVJvdXRlVXBkYXRlIiwiY3JlYXRlZCIsImluQnJvd3NlciIsInJlc29sdmVQYXRoIiwicmVsYXRpdmUiLCJiYXNlIiwiZmlyc3RDaGFyIiwiY2hhckF0Iiwic3RhY2siLCJwb3AiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJzZVBhdGgiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiY2xlYW5QYXRoIiwiaXNhcnJheSIsInBhdGhUb1JlZ2V4cF8xIiwicGF0aFRvUmVnZXhwIiwicGFyc2VfMSIsImNvbXBpbGVfMSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uXzEiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHBfMSIsInRva2Vuc1RvUmVnRXhwIiwiUEFUSF9SRUdFWFAiLCJSZWdFeHAiLCJ0b2tlbnMiLCJpbmRleCIsImRlZmF1bHREZWxpbWl0ZXIiLCJkZWxpbWl0ZXIiLCJlc2NhcGVkIiwicHJlZml4IiwiY2FwdHVyZSIsImdyb3VwIiwibW9kaWZpZXIiLCJhc3RlcmlzayIsInBhcnRpYWwiLCJyZXBlYXQiLCJvcHRpb25hbCIsInBhdHRlcm4iLCJlc2NhcGVHcm91cCIsImVzY2FwZVN0cmluZyIsImVuY29kZVVSSUNvbXBvbmVudFByZXR0eSIsImVuY29kZVVSSSIsInRvVXBwZXJDYXNlIiwiZW5jb2RlQXN0ZXJpc2siLCJtYXRjaGVzIiwib3B0cyIsInByZXR0eSIsInRva2VuIiwiYXR0YWNoS2V5cyIsInJlIiwiZmxhZ3MiLCJzZW5zaXRpdmUiLCJyZWdleHBUb1JlZ2V4cCIsImdyb3VwcyIsImFycmF5VG9SZWdleHAiLCJyZWdleHAiLCJzdHJpbmdUb1JlZ2V4cCIsInN0cmljdCIsImVuZHNXaXRoRGVsaW1pdGVyIiwicmVnZXhwQ29tcGlsZUNhY2hlIiwiY3JlYXRlIiwiZmlsbFBhcmFtcyIsInJvdXRlTXNnIiwiZmlsbGVyIiwiY3JlYXRlUm91dGVNYXAiLCJvbGRQYXRoTGlzdCIsIm9sZFBhdGhNYXAiLCJvbGROYW1lTWFwIiwicGF0aExpc3QiLCJwYXRoTWFwIiwibmFtZU1hcCIsImFkZFJvdXRlUmVjb3JkIiwibCIsInNwbGljZSIsIm1hdGNoQXMiLCJwYXRoVG9SZWdleHBPcHRpb25zIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVQYXRoIiwiY2FzZVNlbnNpdGl2ZSIsInJlZ2V4IiwiY29tcGlsZVJvdXRlUmVnZXgiLCJiZWZvcmVFbnRlciIsInNvbWUiLCJjaGlsZE1hdGNoQXMiLCJhbGlhcyIsImFsaWFzZXMiLCJhbGlhc1JvdXRlIiwibm9ybWFsaXplTG9jYXRpb24iLCJyYXciLCJfbm9ybWFsaXplZCIsImFzc2lnbiIsInJhd1BhdGgiLCJwYXJzZWRQYXRoIiwiYmFzZVBhdGgiLCJjcmVhdGVNYXRjaGVyIiwiYWRkUm91dGVzIiwiY3VycmVudFJvdXRlIiwiX2NyZWF0ZVJvdXRlIiwicGFyYW1OYW1lcyIsInJlY29yZCQxIiwibWF0Y2hSb3V0ZSIsIm9yaWdpbmFsUmVkaXJlY3QiLCJoYXNPd25Qcm9wZXJ0eSIsInRhcmdldFJlY29yZCIsInJlc29sdmVSZWNvcmRQYXRoIiwicmVzb2x2ZWRQYXRoIiwiYWxpYXNlZFBhdGgiLCJhbGlhc2VkTWF0Y2giLCJhbGlhc2VkUmVjb3JkIiwicG9zaXRpb25TdG9yZSIsInNldHVwU2Nyb2xsIiwicmVwbGFjZVN0YXRlIiwiZ2V0U3RhdGVLZXkiLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJzZXRTdGF0ZUtleSIsImhhbmRsZVNjcm9sbCIsImlzUG9wIiwiYmVoYXZpb3IiLCJzY3JvbGxCZWhhdmlvciIsIiRuZXh0VGljayIsInBvc2l0aW9uIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJzaG91bGRTY3JvbGwiLCJ0aGVuIiwic2Nyb2xsVG9Qb3NpdGlvbiIsImNhdGNoIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImdldEVsZW1lbnRQb3NpdGlvbiIsImVsIiwiZG9jRWwiLCJkb2NSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxSZWN0IiwibGVmdCIsInRvcCIsImlzVmFsaWRQb3NpdGlvbiIsImlzTnVtYmVyIiwibm9ybWFsaXplUG9zaXRpb24iLCJub3JtYWxpemVPZmZzZXQiLCJpc09iamVjdCIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsInNjcm9sbFRvIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJfa2V5IiwiZ2VuS2V5IiwidG9GaXhlZCIsInB1c2hTdGF0ZSIsInVybCIsInJ1blF1ZXVlIiwiZm4iLCJjYiIsInN0ZXAiLCJyZXNvbHZlQXN5bmNDb21wb25lbnRzIiwiaGFzQXN5bmMiLCJwZW5kaW5nIiwiZXJyb3IiLCJmbGF0TWFwQ29tcG9uZW50cyIsImRlZiIsImNpZCIsInJlc29sdmVkRGVmIiwiaXNFU01vZHVsZSIsInJlc29sdmVkIiwicmVqZWN0IiwicmVhc29uIiwibXNnIiwiY29tcCIsImZsYXR0ZW4iLCJoYXNTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIl9fZXNNb2R1bGUiLCJjYWxsZWQiLCJIaXN0b3J5Iiwibm9ybWFsaXplQmFzZSIsInJlYWR5IiwicmVhZHlDYnMiLCJyZWFkeUVycm9yQ2JzIiwiZXJyb3JDYnMiLCJsaXN0ZW4iLCJvblJlYWR5IiwiZXJyb3JDYiIsIm9uRXJyb3IiLCJ0cmFuc2l0aW9uVG8iLCJvbkNvbXBsZXRlIiwib25BYm9ydCIsImNvbmZpcm1UcmFuc2l0aW9uIiwidXBkYXRlUm91dGUiLCJlbnN1cmVVUkwiLCJhYm9ydCIsInJlc29sdmVRdWV1ZSIsInVwZGF0ZWQiLCJkZWFjdGl2YXRlZCIsImFjdGl2YXRlZCIsImV4dHJhY3RMZWF2ZUd1YXJkcyIsImJlZm9yZUhvb2tzIiwiZXh0cmFjdFVwZGF0ZUhvb2tzIiwicG9zdEVudGVyQ2JzIiwiaXNWYWxpZCIsImVudGVyR3VhcmRzIiwiZXh0cmFjdEVudGVyR3VhcmRzIiwicmVzb2x2ZUhvb2tzIiwicHJldiIsImFmdGVySG9va3MiLCJiYXNlRWwiLCJleHRyYWN0R3VhcmRzIiwicmVjb3JkcyIsImJpbmQiLCJyZXZlcnNlIiwiZ3VhcmRzIiwiaW5zdGFuY2UiLCJndWFyZCIsImV4dHJhY3RHdWFyZCIsImJpbmRHdWFyZCIsImJvdW5kUm91dGVHdWFyZCIsImNicyIsImJpbmRFbnRlckd1YXJkIiwicm91dGVFbnRlckd1YXJkIiwicG9sbCIsIkhUTUw1SGlzdG9yeSIsIkhpc3RvcnkkJDEiLCJleHBlY3RTY3JvbGwiLCJpbml0TG9jYXRpb24iLCJnZXRMb2NhdGlvbiIsImNvbnN0cnVjdG9yIiwiZ28iLCJmcm9tUm91dGUiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsIkhhc2hIaXN0b3J5IiwiZmFsbGJhY2siLCJjaGVja0ZhbGxiYWNrIiwiZW5zdXJlU2xhc2giLCJzZXR1cExpc3RlbmVycyIsInN1cHBvcnRzU2Nyb2xsIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJnZXRVcmwiLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwic2V0dXBIYXNoTGlzdGVuZXIiLCJyZWdpc3Rlckhvb2siLCJiZWZvcmVSZXNvbHZlIiwiYWZ0ZXJFYWNoIiwiYmFjayIsImZvcndhcmQiLCJnZXRNYXRjaGVkQ29tcG9uZW50cyIsImNyZWF0ZUhyZWYiLCJub3JtYWxpemVkVG8iLCJkZWZpbmVQcm9wZXJ0aWVzIiwibGlzdFRvU3R5bGVzIiwicGFyZW50SWQiLCJzdHlsZXMiLCJuZXdTdHlsZXMiLCJjc3MiLCJtZWRpYSIsInBhcnQiLCJlbXB0eU9iamVjdCIsImlzVW5kZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJfdG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInBhcnNlRmxvYXQiLCJpc1Byb21pc2UiLCJ0b051bWJlciIsIm1ha2VNYXAiLCJleHBlY3RzTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImhhc093biIsImNhY2hlZCIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiY2FwaXRhbGl6ZSIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsIl9sZW5ndGgiLCJuYXRpdmVCaW5kIiwidG9BcnJheSIsIl9mcm9tIiwidG9PYmplY3QiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsInJlZHVjZSIsInN0YXRpY0tleXMiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImdldFRpbWUiLCJrZXlzQSIsImtleXNCIiwibG9vc2VJbmRleE9mIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImFzeW5jIiwiX2xpZmVjeWNsZUhvb2tzIiwidW5pY29kZVJlZ0V4cCIsImlzUmVzZXJ2ZWQiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJiYWlsUkUiLCJoYXNQcm90byIsImluV2VleCIsIldYRW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsIndlZXhQbGF0Zm9ybSIsIlVBIiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsImlzUGhhbnRvbUpTIiwiaXNGRiIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJDdG9yIiwiUmVmbGVjdCIsIm93bktleXMiLCJfU2V0IiwiY2xlYXIiLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJ0cmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJfaXNWdWUiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwidWlkIiwiRGVwIiwic3VicyIsImFkZFN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInNvcnQiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJwb3BUYXJnZXQiLCJWTm9kZSIsImVsbSIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwiY2xvbmVkIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJzaG91bGRPYnNlcnZlIiwidG9nZ2xlT2JzZXJ2aW5nIiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsIm9ic2VydmUiLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsImRlbCIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJkZWR1cGVIb29rcyIsImhvb2tzIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwia2V5JDEiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwiZGVmJCQxIiwibWVyZ2VPcHRpb25zIiwiX2Jhc2UiLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsInN0cmluZ0luZGV4IiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRPYnNlcnZlIiwiYXNzZXJ0UHJvcCIsIl9wcm9wcyIsImdldFR5cGUiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiaGF2ZUV4cGVjdGVkVHlwZXMiLCJ0IiwiZ2V0SW52YWxpZFR5cGVNZXNzYWdlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsImZ1bmN0aW9uVHlwZUNoZWNrUkUiLCJpc1NhbWVUeXBlIiwicmVjZWl2ZWRUeXBlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwic3R5bGVWYWx1ZSIsIkVYUExJQ0FCTEVfVFlQRVMiLCJlbGVtIiwiaGFuZGxlRXJyb3IiLCJpbmZvIiwiY3VyIiwiZXJyb3JDYXB0dXJlZCIsImdsb2JhbEhhbmRsZUVycm9yIiwiaW52b2tlV2l0aEVycm9ySGFuZGxpbmciLCJfaGFuZGxlZCIsImxvZ0Vycm9yIiwiaXNVc2luZ01pY3JvVGFzayIsImNhbGxiYWNrcyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwidGltZXJGdW5jIiwiUHJvbWlzZSIsInAiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsImNoYXJhY3RlckRhdGEiLCJfcmVzb2x2ZSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50Iiwid2FyblJlc2VydmVkUHJlZml4IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsIiRkYXRhIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbGRPbiIsInJlbW92ZSQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib2xkIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsImxhc3RJbmRleCIsIl9pc1ZMaXN0IiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5IiwicHJvdmlkZURlZmF1bHQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJuYW1lJDEiLCJpc1doaXRlc3BhY2UiLCJub3JtYWxpemVTY29wZWRTbG90cyIsIm5vcm1hbFNsb3RzIiwicHJldlNsb3RzIiwiaGFzTm9ybWFsU2xvdHMiLCJpc1N0YWJsZSIsIiRzdGFibGUiLCIka2V5IiwiJGhhc05vcm1hbCIsIm5vcm1hbGl6ZVNjb3BlZFNsb3QiLCJrZXkkMiIsInByb3h5Tm9ybWFsU2xvdCIsInByb3h5IiwicmVuZGVyTGlzdCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2tSZW5kZXIiLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwiJHNjb3BlZFNsb3RzIiwibm9kZXMiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImxvb3AiLCJkb21Qcm9wcyIsImNhbWVsaXplZEtleSIsImh5cGhlbmF0ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJjb250ZW50SGFzaEtleSIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJ2YWx1ZXMiLCJwcmVwZW5kTW9kaWZpZXIiLCJzeW1ib2wiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIl9kIiwiX3AiLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImluamVjdGlvbnMiLCJzY29wZWRTbG90cyIsIl9zY29wZUlkIiwiX2MiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0Iiwidm5vZGVzIiwiZGV2dG9vbHNNZXRhIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImh5ZHJhdGluZyIsIl9pc0Rlc3Ryb3llZCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsImFjdGl2ZUluc3RhbmNlIiwib2xkVm5vZGUiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsImluc2VydCIsIl9pc01vdW50ZWQiLCJjYWxsSG9vayIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRlc3Ryb3kiLCIkZGVzdHJveSIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwibmF0aXZlT24iLCJhYnN0cmFjdCIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwidG9NZXJnZSIsIl9tZXJnZWQiLCJtZXJnZUhvb2skMSIsImYxIiwiZjIiLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsInByZSIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJpbml0UmVuZGVyIiwiX3Zub2RlIiwicGFyZW50Vm5vZGUiLCJfcmVuZGVyQ2hpbGRyZW4iLCJwYXJlbnREYXRhIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiX3BhcmVudExpc3RlbmVycyIsImN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInJlbmRlck1peGluIiwiX3JlbmRlciIsInJlbmRlckVycm9yIiwiZW5zdXJlQ3RvciIsImZhY3RvcnkiLCJlcnJvckNvbXAiLCJvd25lciIsIm93bmVycyIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsInN5bmMiLCJ0aW1lckxvYWRpbmciLCJ0aW1lclRpbWVvdXQiLCJmb3JjZVJlbmRlciIsInJlbmRlckNvbXBsZXRlZCIsIiRmb3JjZVVwZGF0ZSIsImRlbGF5IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJpJDEiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50Iiwic2V0QWN0aXZlSW5zdGFuY2UiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiV2F0Y2hlciIsImJlZm9yZSIsInJlbmRlckNoaWxkcmVuIiwibmV3U2NvcGVkU2xvdHMiLCJvbGRTY29wZWRTbG90cyIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJNQVhfVVBEQVRFX0NPVU5UIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJjdXJyZW50Rmx1c2hUaW1lc3RhbXAiLCJnZXROb3ciLCJjcmVhdGVFdmVudCIsInRpbWVTdGFtcCIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJpc1JlbmRlcldhdGNoZXIiLCJkZWVwIiwibGF6eSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJjbGVhbnVwRGVwcyIsIm9sZFZhbHVlIiwiZXZhbHVhdGUiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsImlzU1NSIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwic2hvdWxkQ2FjaGUiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNyZWF0ZUdldHRlckludm9rZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJ1aWQkMyIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiaW5pdFVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsImluaXRNaXhpbiQxIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwicHJ1bmVDYWNoZSIsImtlZXBBbGl2ZUluc3RhbmNlIiwiZW50cnkiLCJwcnVuZUNhY2hlRW50cnkiLCJwYXR0ZXJuVHlwZXMiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNhY2hlVk5vZGUiLCJ2bm9kZVRvQ2FjaGUiLCJrZXlUb0NhY2hlIiwibW91bnRlZCIsInJlZiQxIiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwiZGVsZXRlIiwib2JzZXJ2YWJsZSIsInNzckNvbnRleHQiLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlIiwiY29udmVydEVudW1lcmF0ZWRWYWx1ZSIsImlzRmFsc3lBdHRyVmFsdWUiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwic2VsZWN0ZWQiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJzZXRTdHlsZVNjb3BlIiwic2NvcGVJZCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwicGFyZW50RWxtIiwicmVmRWxtIiwibmVzdGVkIiwib3duZXJBcnJheSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImNoZWNrRHVwbGljYXRlS2V5cyIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJvbGRBcmciLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJpc0luUHJlIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJmaWx0ZXJzIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInJhbmdlIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJkeW5hbWljIiwicmFuZ2VTZXRJdGVtIiwicGxhaW4iLCJhZGRBdHRyIiwiZHluYW1pY0F0dHJzIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiaXNEeW5hbWljQXJnIiwicHJlcGVuZE1vZGlmaWVyTWFya2VyIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRSYXdCaW5kaW5nQXR0ciIsInJhd0F0dHJzTWFwIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwiZW9mIiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwidmFsdWUkMSIsInR5cGVCaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsInVzZU1pY3JvdGFza0ZpeCIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsIm93bmVyRG9jdW1lbnQiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJzdmdDb250YWluZXIiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzTm90SW5Gb2N1c0FuZERpcnR5IiwiaXNEaXJ0eVdpdGhNb2RpZmllcnMiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJ3aGl0ZXNwYWNlUkUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJkaXJlY3RpdmUiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsImdldFZhbHVlIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiaXNOb3RUZXh0Tm9kZSIsImlzVlNob3dEaXJlY3RpdmUiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsImJlZm9yZU1vdW50Iiwia2VwdCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJyZW1vdmVkIiwiYyQxIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwiZHkiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwicGFyc2VUZXh0IiwidGFnUkUiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQxIiwic3R5bGUkMSIsImRlY29kZXIiLCJoZSIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImF0dHJpYnV0ZSIsImR5bmFtaWNBcmdBdHRyaWJ1dGUiLCJuY25hbWUiLCJxbmFtZUNhcHR1cmUiLCJzdGFydFRhZ09wZW4iLCJzdGFydFRhZ0Nsb3NlIiwiZG9jdHlwZSIsImNvbW1lbnQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicGFyc2VIVE1MIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwic2hvdWxkS2VlcENvbW1lbnQiLCJzdWJzdHJpbmciLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCIsImNoYXJzIiwiZW5kVGFnTGVuZ3RoIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsInJlc3QkMSIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsInNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiIsIm91dHB1dFNvdXJjZVJhbmdlIiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiZHluYW1pY0FyZ1JFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwic2xvdFJFIiwibGluZUJyZWFrUkUiLCJ3aGl0ZXNwYWNlUkUkMSIsImludmFsaWRBdHRyaWJ1dGVSRSIsImRlY29kZUhUTUxDYWNoZWQiLCJlbXB0eVNsb3RTY29wZVRva2VuIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJtYXliZUNvbXBvbmVudCIsImNyZWF0ZUFTVEVsZW1lbnQiLCJtYWtlQXR0cnNNYXAiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJ3aGl0ZXNwYWNlT3B0aW9uIiwid2hpdGVzcGFjZSIsInJvb3QiLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNsb3NlRWxlbWVudCIsInRyaW1FbmRpbmdXaGl0ZXNwYWNlIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0VsZW1lbnQiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJmb3JiaWRkZW4iLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiY29tbWVudHMiLCJzdGFydCQxIiwiZ3VhcmRJRVNWR0J1ZyIsImN1bXVsYXRlZCIsImlzRm9yYmlkZGVuVGFnIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsImVuZCQxIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdENvbnRlbnQiLCJwcm9jZXNzU2xvdE91dGxldCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJmb3IiLCJpdGVyYXRvcjIiLCJpdGVyYXRvcjEiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiaXRlcmF0b3JNYXRjaCIsImZpbmRQcmV2RWxlbWVudCIsImlmQ29uZGl0aW9ucyIsInNsb3RUYXJnZXREeW5hbWljIiwic2xvdEJpbmRpbmciLCJnZXRTbG90TmFtZSIsInNsb3RCaW5kaW5nJDEiLCJkeW5hbWljJDEiLCJzbG90Q29udGFpbmVyIiwic2xvdE5hbWUiLCJzeW5jR2VuIiwiaXNEeW5hbWljIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJmbkludm9rZVJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJrZXlOYW1lcyIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsImN0cmwiLCJhbHQiLCJnZW5IYW5kbGVycyIsInN0YXRpY0hhbmRsZXJzIiwiZHluYW1pY0hhbmRsZXJzIiwiaGFuZGxlckNvZGUiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0Z1bmN0aW9uSW52b2NhdGlvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJvbmNlSWQiLCJnZW5lcmF0ZSIsImFzdCIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJvcmlnaW5hbFByZVN0YXRlIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJjb250YWluc1Nsb3RDaGlsZCIsIm5lZWRzS2V5IiwiZ2VuZXJhdGVkU2xvdHMiLCJnZW5TY29wZWRTbG90IiwiaXNMZWdhY3lTeW50YXgiLCJyZXZlcnNlUHJveHkiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImVsJDEiLCJub3JtYWxpemF0aW9uVHlwZSQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuQ29tbWVudCIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInN0YXRpY1Byb3BzIiwiZHluYW1pY1Byb3BzIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJzdHJpcFN0cmluZ1JFIiwiZGV0ZWN0RXJyb3JzIiwiY2hlY2tOb2RlIiwiY2hlY2tGb3IiLCJjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbiIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdHJpcHBlZCIsImtleXdvcmRNYXRjaCIsImNoZWNrSWRlbnRpZmllciIsImlkZW50IiwiZ2VuZXJhdGVDb2RlRnJhbWUiLCJsaW5lcyIsImNvdW50IiwicmVwZWF0JDEiLCJsaW5lTGVuZ3RoIiwicGFkIiwibGVuZ3RoJDEiLCJjcmVhdGVGdW5jdGlvbiIsImVycm9ycyIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlVG9GdW5jdGlvbnMiLCJ3YXJuJCQxIiwiY29tcGlsZWQiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwibGVhZGluZ1NwYWNlTGVuZ3RoIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJJbnRlcmFjdGlvblR5cGUiLCJGSUxMX0lOIiwiTElLRVJUIiwiVHlwZSIsIklOVEVSQUNUSU9OIiwicXVlc3Rpb24iLCJnZXRWZXJpZmllZFN0YXRlbWVudFZhbHVlIiwiaW50ZXJhY3Rpb25UeXBlIiwiY29ycmVjdFJlc3BvbnNlc1BhdHRlcm4iXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0EsMkNBQTJDLGNBQWM7O1FBRXpEO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7O1FBRUE7UUFDQTs7Ozs7Ozs7Ozs7O0FDaEVBLElBQUlBLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLQyxTQUFTLGFBQVQsR0FBTCxJQUFrQyxDQUFDLEdBQUVDLElBQUgsRUFBUyxNQUFULENBQXRDO0FBQ0EsQ0FIRCxD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QUNILENBQUM7QUFDRDtBQUNBLElBQUksS0FBVTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7O0FDM0RBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQXdUO0FBQzlVLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsQ0FBZ0U7QUFDckY7QUFDQSxHQUFHLEtBQVU7QUFDYjtBQUNBO0FBQ0EsZ0lBQWdJLHNFQUFzRTtBQUN0TSx5SUFBeUksc0VBQXNFO0FBQy9NO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQXVUO0FBQzdVLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsQ0FBZ0U7QUFDckY7QUFDQSxHQUFHLEtBQVU7QUFDYjtBQUNBO0FBQ0EsZ0lBQWdJLHNFQUFzRTtBQUN0TSx5SUFBeUksc0VBQXNFO0FBQy9NO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQyIsImZpbGUiOiJoNXAtZmVlZGJhY2suanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiMGJiNzAyOTQ2Mzg4Y2M4YWRjMiIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXApIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIHZhciBiYXNlNjQgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5pZiAodHlwZW9mIERFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBERUJVRykge1xuICBpZiAoIWhhc0RvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuICcgK1xuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxuICApIH1cbn1cblxudmFyIGxpc3RUb1N0eWxlcyA9IHJlcXVpcmUoJy4vbGlzdFRvU3R5bGVzJylcblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXZ1ZS1zc3ItaWR+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XHJcbmltcG9ydCBSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcic7XHJcbmltcG9ydCBTY29yZUlucHV0IGZyb20gJy4vdmlld3MvU2NvcmVJbnB1dC52dWUnO1xyXG5pbXBvcnQgVGV4dElucHV0IGZyb20gJy4vdmlld3MvVGV4dElucHV0LnZ1ZSc7XHJcbmltcG9ydCBGaW5hbCBmcm9tICcuL3ZpZXdzL0ZpbmFsLnZ1ZSc7XHJcbmltcG9ydCBYQVBJQnVpbGRlciBmcm9tICcuL2NvbXBvbmVudHMveGFwaSc7XHJcblxyXG5pbXBvcnQgRmFjZTEgZnJvbSAnLi4vaW1hZ2VzL2ZhY2UxLnN2Zyc7XHJcbmltcG9ydCBGYWNlMiBmcm9tICcuLi9pbWFnZXMvZmFjZTIuc3ZnJztcclxuaW1wb3J0IEZhY2UzIGZyb20gJy4uL2ltYWdlcy9mYWNlMy5zdmcnO1xyXG5pbXBvcnQgRmFjZTQgZnJvbSAnLi4vaW1hZ2VzL2ZhY2U0LnN2Zyc7XHJcblxyXG5WdWUudXNlKFJvdXRlcik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWVkYmFjayBleHRlbmRzIEg1UC5FdmVudERpc3BhdGNoZXIge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50SWRcclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERhdGFcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb25maWcsIGNvbnRlbnRJZCwgY29udGVudERhdGEgPSB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuY29udGVudElkID0gY29udGVudElkO1xyXG4gICAgdGhpcy54YXBpID0gbmV3IFhBUElCdWlsZGVyKCk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGUgPSBjb250ZW50RGF0YS5wcmV2aW91c1N0YXRlIHx8IHt9O1xyXG5cclxuICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IFtcclxuICAgICAge1xyXG4gICAgICAgIHRpdGxlOiBjb25maWcubDEwbi5zY2FsZVZlcnlTYXRpc2ZpZWQsXHJcbiAgICAgICAgY2xzOiAnZmVlZGJhY2stc2NvcmUtNCcsXHJcbiAgICAgICAgc2NvcmU6ICc0JyxcclxuICAgICAgICBpY29uOiBGYWNlNFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgdGl0bGU6IGNvbmZpZy5sMTBuLnNjYWxlU2F0aXNmaWVkLFxyXG4gICAgICAgIGNsczogJ2ZlZWRiYWNrLXNjb3JlLTMnLFxyXG4gICAgICAgIHNjb3JlOiAnMycsXHJcbiAgICAgICAgaWNvbjogRmFjZTNcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHRpdGxlOiBjb25maWcubDEwbi5zY2FsZU5ldXRyYWwsXHJcbiAgICAgICAgY2xzOiAnZmVlZGJhY2stc2NvcmUtMicsXHJcbiAgICAgICAgc2NvcmU6ICcyJyxcclxuICAgICAgICBpY29uOiBGYWNlMlxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgdGl0bGU6IGNvbmZpZy5sMTBuLnNjYWxlVW5zYXRpc2ZpZWQsXHJcbiAgICAgICAgY2xzOiAnZmVlZGJhY2stc2NvcmUtMScsXHJcbiAgICAgICAgc2NvcmU6ICcxJyxcclxuICAgICAgICBpY29uOiBGYWNlMVxyXG4gICAgICB9XTtcclxuXHJcbiAgICAvLyBzZXQgZGF0YSBvbiB0ZXh0IGlucHV0IHZpZXdcclxuICAgIFRleHRJbnB1dC5kYXRhID0gKCkgPT4gKHtcclxuICAgICAgYWx0ZXJuYXRpdmVzLFxyXG4gICAgICB0ZXh0OiAnJyxcclxuICAgICAgbGFiZWxUZXh0SW5wdXQ6IGNvbmZpZy5sYWJlbFRleHRJbnB1dFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gY3JhdGUgcm91dGVyXHJcbiAgICBjb25zdCByb3V0ZXIgPSBuZXcgUm91dGVyKHtcclxuICAgICAgbW9kZTogJ2Fic3RyYWN0JyxcclxuICAgICAgcm91dGVzOiBbXHJcbiAgICAgICAgeyBwYXRoOiAnL3Njb3JlLWlucHV0JywgY29tcG9uZW50OiBTY29yZUlucHV0LCBwcm9wczogeyBhbHRlcm5hdGl2ZXM6IGFsdGVybmF0aXZlcywgbWVzc2FnZTogY29uZmlnLmxhYmVsU2NvcmVJbnB1dCB9IH0sXHJcbiAgICAgICAgeyBwYXRoOiAnL3RleHQtaW5wdXQvOnNjb3JlJywgY29tcG9uZW50OiBUZXh0SW5wdXQsIHByb3BzOiB0cnVlIH0sXHJcbiAgICAgICAgeyBwYXRoOiAnL2ZpbmFsJywgY29tcG9uZW50OiBGaW5hbCwgcHJvcHM6IHsgZmluaXNoZWRUZXh0OiBjb25maWcuZmluaXNoZWRUZXh0IH0gfSxcclxuICAgICAgICB7IHBhdGg6ICcvJywgcmVkaXJlY3Q6ICcvc2NvcmUtaW5wdXQnIH0sXHJcbiAgICAgIF1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHRyaWdnZXIgcmVzaXplIHdoZW4gc3dpdGNoaW5nIHZpZXdzXHJcbiAgICByb3V0ZXIuYmVmb3JlRWFjaCgodG8sIGZyb20sIG5leHQpID0+IHtcclxuICAgICAgbmV4dCgpO1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gY3JlYXRlIHZpZXcgbW9kZWxcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZ1ZSh7IHJvdXRlciB9KTtcclxuXHJcbiAgICAvLyB1cGRhdGUgc3RhdGVcclxuICAgIHJvdXRlci5hcHAuJG9uKCdzdWJtaXQtc2NvcmUnLCBzY29yZSA9PiBzdGF0ZS5zY29yZSA9IHNjb3JlKTtcclxuICAgIHJvdXRlci5hcHAuJG9uKCdzdWJtaXQtdGV4dCcsIHJlc3BvbnNlVGV4dCA9PiBzdGF0ZS5yZXNwb25zZVRleHQgPSByZXNwb25zZVRleHQpO1xyXG5cclxuICAgIC8vIGZpcmUgeGFwaSBldmVudHMgb24gc2NvcmUgb3IgdGV4dCByZXNwb25zZSB1cGRhdGVzXHJcbiAgICByb3V0ZXIuYXBwLiRvbignc3VibWl0LXNjb3JlJywgc2NvcmUgPT4ge1xyXG4gICAgICBjb25zdCBzY2FsZSA9IGFsdGVybmF0aXZlcy5tYXAodGhpcy5hbHRlcm5hdGl2ZWVUb1NjYWxlKTtcclxuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmNyZWF0ZVhBUElFdmVudFRlbXBsYXRlKCdhbnN3ZXJlZCcpO1xyXG4gICAgICB0aGlzLnhhcGkuY3JlYXRlTGlrZXJ0RXZlbnQoZXZlbnQsIGNvbmZpZy5sYWJlbFNjb3JlSW5wdXQsIHNjb3JlLCBzY2FsZSk7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByb3V0ZXIuYXBwLiRvbignc3VibWl0LXRleHQnLCAgcmVzcG9uc2VUZXh0ID0+IHtcclxuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmNyZWF0ZVhBUElFdmVudFRlbXBsYXRlKCdhbnN3ZXJlZCcpO1xyXG4gICAgICB0aGlzLnhhcGkuY3JlYXRlVGV4dEV2ZW50KGV2ZW50LCByZXNwb25zZVRleHQpO1xyXG4gICAgICB0aGlzLnRyaWdnZXIoZXZlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggbGlicmFyeSB0byB3cmFwcGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR3cmFwcGVyXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNoID0gJHdyYXBwZXIgPT4ge1xyXG4gICAgICBjb25zdCBpZCA9IGBoNXAtZmVlZGJhY2stY29udGVudC0ke3RoaXMuY29udGVudElkfWA7XHJcbiAgICAgICR3cmFwcGVyLmdldCgwKS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZVJvb3RFbGVtZW50KGlkKSk7XHJcbiAgICAgIHRoaXMudmlld01vZGVsLiRtb3VudChgIyR7aWR9YCk7XHJcbiAgICAgIHJvdXRlci5wdXNoKCdzY29yZS1pbnB1dCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0Q3VycmVudFN0YXRlID0gKCkgPT4gc3RhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSByb290IGVsZW1lbnQgdGhhdCB2dWUgd2lsbCByZW5kZXIgaW50b1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlUm9vdEVsZW1lbnQgPSBpZCA9PiB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgZWxlbWVudC5pZCA9IGlkO1xyXG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9ICdoNXAtZmVlZGJhY2snO1xyXG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8cm91dGVyLXZpZXc+PC9yb3V0ZXItdmlldz4nO1xyXG4gICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHhBUEkgc2NhbGUgb2JqZWN0cyB3aGVuIGdpdmVuIGEgYW5cclxuICAgICAqIGFycmF5IG9mIGFsdGVybmF0aXZlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGFsdGVybmF0aXZlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWx0ZXJuYXRpdmVlVG9TY2FsZSA9IGFsdGVybmF0aXZlID0+ICh7XHJcbiAgICAgIGlkOiBhbHRlcm5hdGl2ZS5zY29yZSxcclxuICAgICAgZGVzY3JpcHRpb246IHRoaXMueGFwaS53cmFwQXNUcmFuc2xhdGlvbihhbHRlcm5hdGl2ZS50aXRsZSlcclxuICAgIH0pO1xyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2FwcC5qcyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3R5bGVzL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYmFzZTY0LWpzL2luZGV4LmpzIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYnVmZmVyL2luZGV4LmpzIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaWVlZTc1NC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaXNhcnJheS9pbmRleC5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uIChnbG9iYWwpIHtcblxuICAgIC8vIG1pbmltYWwgc3ltYm9sIHBvbHlmaWxsIGZvciBJRTExIGFuZCBvdGhlcnNcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgU3ltYm9sID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBTeW1ib2wubm9uTmF0aXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBTVEFURV9QTEFJTlRFWFQgPSBTeW1ib2woJ3BsYWludGV4dCcpO1xuICAgIGNvbnN0IFNUQVRFX0hUTUwgICAgICA9IFN5bWJvbCgnaHRtbCcpO1xuICAgIGNvbnN0IFNUQVRFX0NPTU1FTlQgICA9IFN5bWJvbCgnY29tbWVudCcpO1xuXG4gICAgY29uc3QgQUxMT1dFRF9UQUdTX1JFR0VYICA9IC88KFxcdyopPi9nO1xuICAgIGNvbnN0IE5PUk1BTElaRV9UQUdfUkVHRVggPSAvPFxcLz8oW15cXHNcXC8+XSspLztcblxuICAgIGZ1bmN0aW9uIHN0cmlwdGFncyhodG1sLCBhbGxvd2FibGVfdGFncywgdGFnX3JlcGxhY2VtZW50KSB7XG4gICAgICAgIGh0bWwgICAgICAgICAgICA9IGh0bWwgfHwgJyc7XG4gICAgICAgIGFsbG93YWJsZV90YWdzICA9IGFsbG93YWJsZV90YWdzIHx8IFtdO1xuICAgICAgICB0YWdfcmVwbGFjZW1lbnQgPSB0YWdfcmVwbGFjZW1lbnQgfHwgJyc7XG5cbiAgICAgICAgbGV0IGNvbnRleHQgPSBpbml0X2NvbnRleHQoYWxsb3dhYmxlX3RhZ3MsIHRhZ19yZXBsYWNlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIHN0cmlwdGFnc19pbnRlcm5hbChodG1sLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0X3N0cmlwdGFnc19zdHJlYW0oYWxsb3dhYmxlX3RhZ3MsIHRhZ19yZXBsYWNlbWVudCkge1xuICAgICAgICBhbGxvd2FibGVfdGFncyAgPSBhbGxvd2FibGVfdGFncyB8fCBbXTtcbiAgICAgICAgdGFnX3JlcGxhY2VtZW50ID0gdGFnX3JlcGxhY2VtZW50IHx8ICcnO1xuXG4gICAgICAgIGxldCBjb250ZXh0ID0gaW5pdF9jb250ZXh0KGFsbG93YWJsZV90YWdzLCB0YWdfcmVwbGFjZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdHJpcHRhZ3Nfc3RyZWFtKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpcHRhZ3NfaW50ZXJuYWwoaHRtbCB8fCAnJywgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RyaXB0YWdzLmluaXRfc3RyZWFtaW5nX21vZGUgPSBpbml0X3N0cmlwdGFnc19zdHJlYW07XG5cbiAgICBmdW5jdGlvbiBpbml0X2NvbnRleHQoYWxsb3dhYmxlX3RhZ3MsIHRhZ19yZXBsYWNlbWVudCkge1xuICAgICAgICBhbGxvd2FibGVfdGFncyA9IHBhcnNlX2FsbG93YWJsZV90YWdzKGFsbG93YWJsZV90YWdzKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dhYmxlX3RhZ3MgOiBhbGxvd2FibGVfdGFncyxcbiAgICAgICAgICAgIHRhZ19yZXBsYWNlbWVudDogdGFnX3JlcGxhY2VtZW50LFxuXG4gICAgICAgICAgICBzdGF0ZSAgICAgICAgIDogU1RBVEVfUExBSU5URVhULFxuICAgICAgICAgICAgdGFnX2J1ZmZlciAgICA6ICcnLFxuICAgICAgICAgICAgZGVwdGggICAgICAgICA6IDAsXG4gICAgICAgICAgICBpbl9xdW90ZV9jaGFyIDogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpcHRhZ3NfaW50ZXJuYWwoaHRtbCwgY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIGh0bWwgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidodG1sJyBwYXJhbWV0ZXIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhbGxvd2FibGVfdGFncyAgPSBjb250ZXh0LmFsbG93YWJsZV90YWdzO1xuICAgICAgICBsZXQgdGFnX3JlcGxhY2VtZW50ID0gY29udGV4dC50YWdfcmVwbGFjZW1lbnQ7XG5cbiAgICAgICAgbGV0IHN0YXRlICAgICAgICAgPSBjb250ZXh0LnN0YXRlO1xuICAgICAgICBsZXQgdGFnX2J1ZmZlciAgICA9IGNvbnRleHQudGFnX2J1ZmZlcjtcbiAgICAgICAgbGV0IGRlcHRoICAgICAgICAgPSBjb250ZXh0LmRlcHRoO1xuICAgICAgICBsZXQgaW5fcXVvdGVfY2hhciA9IGNvbnRleHQuaW5fcXVvdGVfY2hhcjtcbiAgICAgICAgbGV0IG91dHB1dCAgICAgICAgPSAnJztcblxuICAgICAgICBmb3IgKGxldCBpZHggPSAwLCBsZW5ndGggPSBodG1sLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSBodG1sW2lkeF07XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gU1RBVEVfUExBSU5URVhUKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgICAgICAgPSBTVEFURV9IVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gU1RBVEVfSFRNTCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSAnPCcgaWYgaW5zaWRlIGEgcXVvdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbl9xdW90ZV9jaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHNlZWluZyBhIG5lc3RlZCAnPCdcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSAnPicgaWYgaW5zaWRlIGEgcXVvdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbl9xdW90ZV9jaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvbWV0aGluZyBsaWtlIHRoaXMgaXMgaGFwcGVuaW5nOiAnPDw+PidcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBjbG9zaW5nIHRoZSB0YWcgaW4gdGFnX2J1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5fcXVvdGVfY2hhciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgICAgICAgICA9IFNUQVRFX1BMQUlOVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgICArPSAnPic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd2FibGVfdGFncy5oYXMobm9ybWFsaXplX3RhZyh0YWdfYnVmZmVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdGFnX2J1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHRhZ19yZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXCcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggYm90aCBzaW5nbGUgYW5kIGRvdWJsZSBxdW90ZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGluX3F1b3RlX2NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbl9xdW90ZV9jaGFyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX3F1b3RlX2NoYXIgPSBpbl9xdW90ZV9jaGFyIHx8IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19idWZmZXIgPT09ICc8IS0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9DT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfYnVmZmVyICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdfYnVmZmVyID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSAgICAgID0gU1RBVEVfUExBSU5URVhUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCAgICArPSAnPCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfYnVmZmVyICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gU1RBVEVfQ09NTUVOVCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdfYnVmZmVyLnNsaWNlKC0yKSA9PSAnLS0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFX1BMQUlOVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgdGhlIGNvbnRleHQgZm9yIGZ1dHVyZSBpdGVyYXRpb25zXG4gICAgICAgIGNvbnRleHQuc3RhdGUgICAgICAgICA9IHN0YXRlO1xuICAgICAgICBjb250ZXh0LnRhZ19idWZmZXIgICAgPSB0YWdfYnVmZmVyO1xuICAgICAgICBjb250ZXh0LmRlcHRoICAgICAgICAgPSBkZXB0aDtcbiAgICAgICAgY29udGV4dC5pbl9xdW90ZV9jaGFyID0gaW5fcXVvdGVfY2hhcjtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlX2FsbG93YWJsZV90YWdzKGFsbG93YWJsZV90YWdzKSB7XG4gICAgICAgIGxldCB0YWdfc2V0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWxsb3dhYmxlX3RhZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBBTExPV0VEX1RBR1NfUkVHRVguZXhlYyhhbGxvd2FibGVfdGFncykpKSB7XG4gICAgICAgICAgICAgICAgdGFnX3NldC5hZGQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoIVN5bWJvbC5ub25OYXRpdmUgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIGFsbG93YWJsZV90YWdzW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgdGFnX3NldCA9IG5ldyBTZXQoYWxsb3dhYmxlX3RhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFsbG93YWJsZV90YWdzLmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIElFMTEgY29tcGF0aWJsZVxuICAgICAgICAgICAgYWxsb3dhYmxlX3RhZ3MuZm9yRWFjaCh0YWdfc2V0LmFkZCwgdGFnX3NldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFnX3NldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVfdGFnKHRhZ19idWZmZXIpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gTk9STUFMSVpFX1RBR19SRUdFWC5leGVjKHRhZ19idWZmZXIpO1xuXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1EXG4gICAgICAgIGRlZmluZShmdW5jdGlvbiBtb2R1bGVfZmFjdG9yeSgpIHsgcmV0dXJuIHN0cmlwdGFnczsgfSk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgLy8gTm9kZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHN0cmlwdGFncztcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlclxuICAgICAgICBnbG9iYWwuc3RyaXB0YWdzID0gc3RyaXB0YWdzO1xuICAgIH1cbn0odGhpcykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdHJpcHRhZ3Mvc3JjL3N0cmlwdGFncy5qcyIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgcm9sZT1cInJlZ2lvblwiIGNsYXNzPVwiaDVwLWZlZWRiYWNrLWZpbmFsXCIgdi1odG1sPVwiZmluaXNoZWRUZXh0XCI+PC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gIGV4cG9ydCBkZWZhdWx0IHtcclxuICAgIG5hbWU6ICdmaW5hbC12aWV3JyxcclxuICAgIHByb3BzOiBbJ2ZpbmlzaGVkVGV4dCddXHJcbiAgfVxyXG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gRmluYWwudnVlPzRkMDdlODViIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgcm9sZT1cInJlZ2lvblwiIGNsYXNzPVwiaDVwLWZlZWRiYWNrLXNjb3JlXCI+XHJcbiAgICA8aDMgY2xhc3M9XCJmZWVkYmFjay10aXRsZVwiIHYtaHRtbD1cIm1lc3NhZ2VcIj48L2gzPlxyXG5cclxuICAgIDx1bCBjbGFzcz1cImZlZWRiYWNrLXNjb3JlLWlucHV0XCI+XHJcbiAgICAgIDxsaSB2LWZvcj1cImFsdGVybmF0aXZlIGluIGFsdGVybmF0aXZlc1wiPlxyXG4gICAgICAgIDxkaXYgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIHYtb246Y2xpY2s9XCJzZW5kU2NvcmUoYWx0ZXJuYXRpdmUpXCI+XHJcbiAgICAgICAgICA8ZGl2IHYtaHRtbD1cImFsdGVybmF0aXZlLmljb25cIiA6Y2xhc3M9XCJhbHRlcm5hdGl2ZS5jbHNcIj48L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmZWVkYmFjay1zY29yZS10aXRsZVwiPnt7IGFsdGVybmF0aXZlLnRpdGxlIH19PC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvbGk+XHJcbiAgICA8L3VsPlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBuYW1lOiAnc2NvcmUtaW5wdXQtdmlldycsXHJcbiAgICBwcm9wczogWydhbHRlcm5hdGl2ZXMnLCAnbWVzc2FnZSddLFxyXG5cclxuICAgIGRhdGE6ICgpID0+ICh7XHJcbiAgICAgIHNjb3JlOiAnMCdcclxuICAgIH0pLFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgc2VuZFNjb3JlOiBmdW5jdGlvbihhbHRlcm5hdGl2ZSkge1xyXG4gICAgICAgIHRoaXMuc2NvcmUgPSBhbHRlcm5hdGl2ZS5zY29yZTtcclxuICAgICAgICB0aGlzLiRyb3V0ZXIuYXBwLiRlbWl0KCdzdWJtaXQtc2NvcmUnLCBhbHRlcm5hdGl2ZS5zY29yZSk7XHJcbiAgICAgICAgdGhpcy4kcm91dGVyLnB1c2goYHRleHQtaW5wdXQvJHthbHRlcm5hdGl2ZS5zY29yZX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInNjc3NcIiB0eXBlPVwidGV4dC9zY3NzXCI+XHJcbiRpY29uLXNpemU6IDUwcHg7XHJcbiRmZWVkYmFjay1zY29yZS1tYXJnaW46IDFlbTtcclxuJGZlZWRiYWNrLXNjb3JlLXRpdGxlLWRpc3BsYWNlbWVudDogMmVtO1xyXG5cclxuJGxpZ2h0Qmx1ZTogI2E0YzNlZjtcclxuJGRhcmtHcmVlbjogIzYzYTk2ZDtcclxuJGxpZ2h0R3JlZW46ICNhM2FhNjY7XHJcbiRvcmFuZ2U6ICNlMzg3NDM7XHJcbiRyZWQ6ICNjODVlNWY7XHJcbiRncmF5OiAjQjlCOUI5O1xyXG5cclxuLmZlZWRiYWNrLXNjb3JlLWlucHV0IHtcclxuICBtYXJnaW4tdG9wOiAtMWVtO1xyXG4gIGZsb2F0OiByaWdodDtcclxuXHJcbiAgbGkge1xyXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gIH1cclxuXHJcbiAgW3JvbGU9XCJidXR0b25cIl0ge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgbWFyZ2luOiAwICRmZWVkYmFjay1zY29yZS1tYXJnaW4gJGZlZWRiYWNrLXNjb3JlLXRpdGxlLWRpc3BsYWNlbWVudCAkZmVlZGJhY2stc2NvcmUtbWFyZ2luO1xyXG4gICAgaGVpZ2h0OiAkaWNvbi1zaXplO1xyXG4gICAgd2lkdGg6ICRpY29uLXNpemU7XHJcbiAgICBvdXRsaW5lOiBub25lO1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG5cclxuICAgICY6Zm9jdXMsXHJcbiAgICAmOmhvdmVyIHtcclxuICAgICAgLmZlZWRiYWNrLXNjb3JlLTQgLmZhY2Uge1xyXG4gICAgICAgIGZpbGw6ICRkYXJrR3JlZW47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5mZWVkYmFjay1zY29yZS0zIC5mYWNlIHtcclxuICAgICAgICBmaWxsOiAkbGlnaHRHcmVlbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmZlZWRiYWNrLXNjb3JlLTIgLmZhY2Uge1xyXG4gICAgICAgIGZpbGw6ICRvcmFuZ2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5mZWVkYmFjay1zY29yZS0xIC5mYWNlIHtcclxuICAgICAgICBmaWxsOiAkcmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuZmVlZGJhY2stc2NvcmUtdGl0bGUge1xyXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuZmFjZSB7XHJcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwcHgpO1xyXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTBweCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5zaGFkb3cge1xyXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGVYKDAuNykgdHJhbnNsYXRlWCgkaWNvbi1zaXplICogMC4xNSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC5mZWVkYmFjay1zY29yZS10aXRsZSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBib3R0b206IC0kZmVlZGJhY2stc2NvcmUtdGl0bGUtZGlzcGxhY2VtZW50O1xyXG4gICAgbGVmdDogMDtcclxuICAgIHJpZ2h0OiAwO1xyXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcclxuICAgIG1hcmdpbjogYXV0bztcclxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XHJcbiAgICBkaXNwbGF5OiBub25lO1xyXG4gIH1cclxuXHJcblxyXG4gIC5mYWNlLWNvbnRhaW5lciB7XHJcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcclxuICB9XHJcblxyXG4gIC5mYWNlIHtcclxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIC4ycyBlYXNlLWluO1xyXG4gICAgdHJhbnNpdGlvbjogYWxsIC4ycyBlYXNlLWluO1xyXG4gICAgZmlsbDogJGxpZ2h0Qmx1ZTtcclxuICB9XHJcblxyXG4gIC5zaGFkb3cge1xyXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjJzIGVhc2UtaW47XHJcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjJzIGVhc2UtaW47XHJcbiAgICBmaWxsOiAkZ3JheTtcclxuICB9XHJcbn1cclxuPC9zdHlsZT5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gU2NvcmVJbnB1dC52dWU/MzIwYWVkMzYiLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiByb2xlPVwicmVnaW9uXCIgY2xhc3M9XCJmZWVkYmFjay10ZXh0LWlucHV0XCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZnJvbS1zY29yZS1pbnB1dFwiPlxyXG4gICAgICA8c3BhbiBjbGFzcz1cImZlZWRiYWNrLXNjb3JlXCIgdi1iaW5kOmNsYXNzPVwiYWx0ZXJuYXRpdmUuY2xzXCI+PC9zcGFuPlxyXG4gICAgICA8c3BhbiBjbGFzcz1cImZlZWRiYWNrLXNjb3JlLXRpdGxlXCI+e3sgdGhpcy5hbHRlcm5hdGl2ZS50aXRsZSB9fTwvc3Bhbj5cclxuICAgICAgPHJvdXRlci1saW5rIHRvPVwiL3Njb3JlLWlucHV0XCI+Q2hhbmdlPC9yb3V0ZXItbGluaz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDxkaXYgdi1odG1sPVwibGFiZWxUZXh0SW5wdXRcIj48L2Rpdj5cclxuXHJcbiAgICA8dGV4dGFyZWEgcm93cz1cIjRcIiBwbGFjZWhvbGRlcj1cIllvdXIgRmVlZGJhY2tcIiB2LW1vZGVsPVwidGV4dFwiPjwvdGV4dGFyZWE+XHJcbiAgICA8YnV0dG9uIHYtYmluZDpkaXNhYmxlZD1cInRleHQubGVuZ3RoIDwgMVwiIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1wcmltYXJ5XCIgdi1vbjpjbGljaz1cInNlbmRUZXh0KHRleHQpXCI+U2VuZDwvYnV0dG9uPlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBuYW1lOiAndGV4dC1pbnB1dC12aWV3JyxcclxuICAgIHByb3BzOiBbJ3Njb3JlJ10sXHJcblxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgYWx0ZXJuYXRpdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFsdGVybmF0aXZlc1xyXG4gICAgICAgICAgLmZpbHRlcihhbHRlcm5hdGl2ZSA9PiBhbHRlcm5hdGl2ZS5zY29yZSA9PT0gdGhpcy5zY29yZSlbMF07XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICBzZW5kVGV4dDogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAgIHRoaXMuJHJvdXRlci5hcHAuJGVtaXQoJ3N1Ym1pdC10ZXh0JywgdGV4dCk7XHJcbiAgICAgICAgdGhpcy4kcm91dGVyLnB1c2goJy9maW5hbCcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHR5cGU9XCJ0ZXh0L3Njc3NcIj5cclxuLmZlZWRiYWNrLXRleHQtaW5wdXQge1xyXG4gIC5mcm9tLXNjb3JlLWlucHV0IHtcclxuICAgIG1hcmdpbi1ib3R0b206IDJlbTtcclxuICB9XHJcblxyXG4gIC5mZWVkYmFjay1zY29yZSB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICB3aWR0aDogMi41ZW07XHJcbiAgICBoZWlnaHQ6IDIuNWVtO1xyXG4gICAgbWFyZ2luLXJpZ2h0OiAxZW07XHJcbiAgICBtYXJnaW4tYm90dG9tOiAtMWVtO1xyXG4gIH1cclxuXHJcbiAgLmZlZWRiYWNrLXNjb3JlLXRpdGxlIHtcclxuICAgIG1hcmdpbi1yaWdodDogMWVtO1xyXG4gIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gVGV4dElucHV0LnZ1ZT9jM2NmYjYxYSIsIi8qKlxuICAqIHZ1ZS1yb3V0ZXIgdjIuOC4xXG4gICogKGMpIDIwMTcgRXZhbiBZb3VcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8qICAqL1xuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmRpdGlvbikge1xuICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4oKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IgKGVycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikuaW5kZXhPZignRXJyb3InKSA+IC0xXG59XG5cbnZhciBWaWV3ID0ge1xuICBuYW1lOiAncm91dGVyLXZpZXcnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKF8sIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcblxuICAgIGRhdGEucm91dGVyVmlldyA9IHRydWU7XG5cbiAgICAvLyBkaXJlY3RseSB1c2UgcGFyZW50IGNvbnRleHQncyBjcmVhdGVFbGVtZW50KCkgZnVuY3Rpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBvbmVudHMgcmVuZGVyZWQgYnkgcm91dGVyLXZpZXcgY2FuIHJlc29sdmUgbmFtZWQgc2xvdHNcbiAgICB2YXIgaCA9IHBhcmVudC4kY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gICAgdmFyIHJvdXRlID0gcGFyZW50LiRyb3V0ZTtcbiAgICB2YXIgY2FjaGUgPSBwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSB8fCAocGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgPSB7fSk7XG5cbiAgICAvLyBkZXRlcm1pbmUgY3VycmVudCB2aWV3IGRlcHRoLCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHJlZVxuICAgIC8vIGhhcyBiZWVuIHRvZ2dsZWQgaW5hY3RpdmUgYnV0IGtlcHQtYWxpdmUuXG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB2YXIgaW5hY3RpdmUgPSBmYWxzZTtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5fcm91dGVyUm9vdCAhPT0gcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LiR2bm9kZSAmJiBwYXJlbnQuJHZub2RlLmRhdGEucm91dGVyVmlldykge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5faW5hY3RpdmUpIHtcbiAgICAgICAgaW5hY3RpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIGRhdGEucm91dGVyVmlld0RlcHRoID0gZGVwdGg7XG5cbiAgICAvLyByZW5kZXIgcHJldmlvdXMgdmlldyBpZiB0aGUgdHJlZSBpcyBpbmFjdGl2ZSBhbmQga2VwdC1hbGl2ZVxuICAgIGlmIChpbmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGgoY2FjaGVbbmFtZV0sIGRhdGEsIGNoaWxkcmVuKVxuICAgIH1cblxuICAgIHZhciBtYXRjaGVkID0gcm91dGUubWF0Y2hlZFtkZXB0aF07XG4gICAgLy8gcmVuZGVyIGVtcHR5IG5vZGUgaWYgbm8gbWF0Y2hlZCByb3V0ZVxuICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgY2FjaGVbbmFtZV0gPSBudWxsO1xuICAgICAgcmV0dXJuIGgoKVxuICAgIH1cblxuICAgIHZhciBjb21wb25lbnQgPSBjYWNoZVtuYW1lXSA9IG1hdGNoZWQuY29tcG9uZW50c1tuYW1lXTtcblxuICAgIC8vIGF0dGFjaCBpbnN0YW5jZSByZWdpc3RyYXRpb24gaG9va1xuICAgIC8vIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGluc3RhbmNlJ3MgaW5qZWN0ZWQgbGlmZWN5Y2xlIGhvb2tzXG4gICAgZGF0YS5yZWdpc3RlclJvdXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIHZhbCkge1xuICAgICAgLy8gdmFsIGNvdWxkIGJlIHVuZGVmaW5lZCBmb3IgdW5yZWdpc3RyYXRpb25cbiAgICAgIHZhciBjdXJyZW50ID0gbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgICh2YWwgJiYgY3VycmVudCAhPT0gdm0pIHx8XG4gICAgICAgICghdmFsICYmIGN1cnJlbnQgPT09IHZtKVxuICAgICAgKSB7XG4gICAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsc28gcmVnaXN0ZXIgaW5zdGFuY2UgaW4gcHJlcGF0Y2ggaG9va1xuICAgIC8vIGluIGNhc2UgdGhlIHNhbWUgY29tcG9uZW50IGluc3RhbmNlIGlzIHJldXNlZCBhY3Jvc3MgZGlmZmVyZW50IHJvdXRlc1xuICAgIDsoZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSkpLnByZXBhdGNoID0gZnVuY3Rpb24gKF8sIHZub2RlKSB7XG4gICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyByZXNvbHZlIHByb3BzXG4gICAgdmFyIHByb3BzVG9QYXNzID0gZGF0YS5wcm9wcyA9IHJlc29sdmVQcm9wcyhyb3V0ZSwgbWF0Y2hlZC5wcm9wcyAmJiBtYXRjaGVkLnByb3BzW25hbWVdKTtcbiAgICBpZiAocHJvcHNUb1Bhc3MpIHtcbiAgICAgIC8vIGNsb25lIHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICAgIHByb3BzVG9QYXNzID0gZGF0YS5wcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHNUb1Bhc3MpO1xuICAgICAgLy8gcGFzcyBub24tZGVjbGFyZWQgcHJvcHMgYXMgYXR0cnNcbiAgICAgIHZhciBhdHRycyA9IGRhdGEuYXR0cnMgPSBkYXRhLmF0dHJzIHx8IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzVG9QYXNzKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50LnByb3BzIHx8ICEoa2V5IGluIGNvbXBvbmVudC5wcm9wcykpIHtcbiAgICAgICAgICBhdHRyc1trZXldID0gcHJvcHNUb1Bhc3Nba2V5XTtcbiAgICAgICAgICBkZWxldGUgcHJvcHNUb1Bhc3Nba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjb25maWdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwicHJvcHMgaW4gXFxcIlwiICsgKHJvdXRlLnBhdGgpICsgXCJcXFwiIGlzIGEgXCIgKyAodHlwZW9mIGNvbmZpZykgKyBcIiwgXCIgK1xuICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKiAgKi9cblxudmFyIGVuY29kZVJlc2VydmVSRSA9IC9bIScoKSpdL2c7XG52YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7IH07XG52YXIgY29tbWFSRSA9IC8lMkMvZztcblxuLy8gZml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29uZm9ybWFudCB0byBSRkMzOTg2OlxuLy8gLSBlc2NhcGVzIFshJygpKl1cbi8vIC0gcHJlc2VydmUgY29tbWFzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgLnJlcGxhY2UoZW5jb2RlUmVzZXJ2ZVJFLCBlbmNvZGVSZXNlcnZlUmVwbGFjZXIpXG4gIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XG5cbnZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXG4gIHF1ZXJ5LFxuICBleHRyYVF1ZXJ5LFxuICBfcGFyc2VRdWVyeVxuKSB7XG4gIGlmICggZXh0cmFRdWVyeSA9PT0gdm9pZCAwICkgZXh0cmFRdWVyeSA9IHt9O1xuXG4gIHZhciBwYXJzZSA9IF9wYXJzZVF1ZXJ5IHx8IHBhcnNlUXVlcnk7XG4gIHZhciBwYXJzZWRRdWVyeTtcbiAgdHJ5IHtcbiAgICBwYXJzZWRRdWVyeSA9IHBhcnNlKHF1ZXJ5IHx8ICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgZS5tZXNzYWdlKTtcbiAgICBwYXJzZWRRdWVyeSA9IHt9O1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBleHRyYVF1ZXJ5KSB7XG4gICAgcGFyc2VkUXVlcnlba2V5XSA9IGV4dHJhUXVlcnlba2V5XTtcbiAgfVxuICByZXR1cm4gcGFyc2VkUXVlcnlcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWVyeSAocXVlcnkpIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydHMuc2hpZnQoKSk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDBcbiAgICAgID8gZGVjb2RlKHBhcnRzLmpvaW4oJz0nKSlcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChyZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzW2tleV0pKSB7XG4gICAgICByZXNba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trZXldID0gW3Jlc1trZXldLCB2YWxdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSAob2JqKSB7XG4gIHZhciByZXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGtleSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsMikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbClcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGw7XG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcbn1cblxuLyogICovXG5cblxudmFyIHRyYWlsaW5nU2xhc2hSRSA9IC9cXC8/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlIChcbiAgcmVjb3JkLFxuICBsb2NhdGlvbixcbiAgcmVkaXJlY3RlZEZyb20sXG4gIHJvdXRlclxuKSB7XG4gIHZhciBzdHJpbmdpZnlRdWVyeSQkMSA9IHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcblxuICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeSB8fCB7fTtcbiAgdHJ5IHtcbiAgICBxdWVyeSA9IGNsb25lKHF1ZXJ5KTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcm91dGUgPSB7XG4gICAgbmFtZTogbG9jYXRpb24ubmFtZSB8fCAocmVjb3JkICYmIHJlY29yZC5uYW1lKSxcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcbiAgICBoYXNoOiBsb2NhdGlvbi5oYXNoIHx8ICcnLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcbiAgICBmdWxsUGF0aDogZ2V0RnVsbFBhdGgobG9jYXRpb24sIHN0cmluZ2lmeVF1ZXJ5JCQxKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSwgc3RyaW5naWZ5UXVlcnkkJDEpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdXRlKVxufVxuXG5mdW5jdGlvbiBjbG9uZSAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChjbG9uZSlcbiAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgcmVzW2tleV0gPSBjbG9uZSh2YWx1ZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcbnZhciBTVEFSVCA9IGNyZWF0ZVJvdXRlKG51bGwsIHtcbiAgcGF0aDogJy8nXG59KTtcblxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xuICB2YXIgcmVzID0gW107XG4gIHdoaWxlIChyZWNvcmQpIHtcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAoXG4gIHJlZixcbiAgX3N0cmluZ2lmeVF1ZXJ5XG4pIHtcbiAgdmFyIHBhdGggPSByZWYucGF0aDtcbiAgdmFyIHF1ZXJ5ID0gcmVmLnF1ZXJ5OyBpZiAoIHF1ZXJ5ID09PSB2b2lkIDAgKSBxdWVyeSA9IHt9O1xuICB2YXIgaGFzaCA9IHJlZi5oYXNoOyBpZiAoIGhhc2ggPT09IHZvaWQgMCApIGhhc2ggPSAnJztcblxuICB2YXIgc3RyaW5naWZ5ID0gX3N0cmluZ2lmeVF1ZXJ5IHx8IHN0cmluZ2lmeVF1ZXJ5O1xuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHN0cmluZ2lmeShxdWVyeSkgKyBoYXNoXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XG4gIGlmIChiID09PSBTVEFSVCkge1xuICAgIHJldHVybiBhID09PSBiXG4gIH0gZWxzZSBpZiAoIWIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcbiAgICApXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSB7XG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcblxuICAvLyBoYW5kbGUgbnVsbCB2YWx1ZSAjMTU2NlxuICBpZiAoIWEgfHwgIWIpIHsgcmV0dXJuIGEgPT09IGIgfVxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGFWYWwgPSBhW2tleV07XG4gICAgdmFyIGJWYWwgPSBiW2tleV07XG4gICAgLy8gY2hlY2sgbmVzdGVkIGVxdWFsaXR5XG4gICAgaWYgKHR5cGVvZiBhVmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYlZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBpc09iamVjdEVxdWFsKGFWYWwsIGJWYWwpXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYVZhbCkgPT09IFN0cmluZyhiVmFsKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKS5pbmRleE9mKFxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcbiAgICApID09PSAwICYmXG4gICAgKCF0YXJnZXQuaGFzaCB8fCBjdXJyZW50Lmhhc2ggPT09IHRhcmdldC5oYXNoKSAmJlxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxuICApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SW5jbHVkZXMgKGN1cnJlbnQsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyogICovXG5cbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXG52YXIgdG9UeXBlcyA9IFtTdHJpbmcsIE9iamVjdF07XG52YXIgZXZlbnRUeXBlcyA9IFtTdHJpbmcsIEFycmF5XTtcblxudmFyIExpbmsgPSB7XG4gIG5hbWU6ICdyb3V0ZXItbGluaycsXG4gIHByb3BzOiB7XG4gICAgdG86IHtcbiAgICAgIHR5cGU6IHRvVHlwZXMsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYSdcbiAgICB9LFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBldmVudFR5cGVzLFxuICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLiRyb3V0ZXI7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLiRyb3V0ZTtcbiAgICB2YXIgcmVmID0gcm91dGVyLnJlc29sdmUodGhpcy50bywgY3VycmVudCwgdGhpcy5hcHBlbmQpO1xuICAgIHZhciBsb2NhdGlvbiA9IHJlZi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGUgPSByZWYucm91dGU7XG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcblxuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgdmFyIGdsb2JhbEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzO1xuICAgIHZhciBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0V4YWN0QWN0aXZlQ2xhc3M7XG4gICAgLy8gU3VwcG9ydCBnbG9iYWwgZW1wdHkgYWN0aXZlIGNsYXNzXG4gICAgdmFyIGFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/ICdyb3V0ZXItbGluay1hY3RpdmUnXG4gICAgICAgICAgICA6IGdsb2JhbEFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWV4YWN0LWFjdGl2ZSdcbiAgICAgICAgICAgIDogZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gYWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzID0gdGhpcy5leGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgICAgICA6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGhcbiAgICAgID8gY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcilcbiAgICAgIDogcm91dGU7XG5cbiAgICBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdID0gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XG4gICAgICA/IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogY2xhc3Nlc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCA8YT4gY2hpbGQgYW5kIGFwcGx5IGxpc3RlbmVyIGFuZCBocmVmXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSA8YT4gaXMgYSBzdGF0aWMgbm9kZVxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRlbmQgPSBfVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICB2YXIgYURhdGEgPSBhLmRhdGEgPSBleHRlbmQoe30sIGEuZGF0YSk7XG4gICAgICAgIGFEYXRhLm9uID0gb247XG4gICAgICAgIHZhciBhQXR0cnMgPSBhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycyk7XG4gICAgICAgIGFBdHRycy5ocmVmID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSA8YT4gY2hpbGQsIGFwcGx5IGxpc3RlbmVyIHRvIHNlbGZcbiAgICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9XG59O1xuXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gIGlmIChlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gIGlmIChlLmN1cnJlbnRUYXJnZXQgJiYgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxuICB9XG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgX1Z1ZTtcblxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCAmJiBfVnVlID09PSBWdWUpIHsgcmV0dXJuIH1cbiAgaW5zdGFsbC5pbnN0YWxsZWQgPSB0cnVlO1xuXG4gIF9WdWUgPSBWdWU7XG5cbiAgdmFyIGlzRGVmID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfTtcblxuICB2YXIgcmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgY2FsbFZhbCkge1xuICAgIHZhciBpID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS5kYXRhKSAmJiBpc0RlZihpID0gaS5yZWdpc3RlclJvdXRlSW5zdGFuY2UpKSB7XG4gICAgICBpKHZtLCBjYWxsVmFsKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLm1peGluKHtcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSAoKSB7XG4gICAgICBpZiAoaXNEZWYodGhpcy4kb3B0aW9ucy5yb3V0ZXIpKSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XG4gICAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMsICdfcm91dGUnLCB0aGlzLl9yb3V0ZXIuaGlzdG9yeS5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSAodGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC5fcm91dGVyUm9vdCkgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgdGhpcyk7XG4gICAgfSxcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGVyJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlciB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlIH1cbiAgfSk7XG5cbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLXZpZXcnLCBWaWV3KTtcbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLWxpbmsnLCBMaW5rKTtcblxuICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gIC8vIHVzZSB0aGUgc2FtZSBob29rIG1lcmdpbmcgc3RyYXRlZ3kgZm9yIHJvdXRlIGhvb2tzXG4gIHN0cmF0cy5iZWZvcmVSb3V0ZUVudGVyID0gc3RyYXRzLmJlZm9yZVJvdXRlTGVhdmUgPSBzdHJhdHMuYmVmb3JlUm91dGVVcGRhdGUgPSBzdHJhdHMuY3JlYXRlZDtcbn1cblxuLyogICovXG5cbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoIChcbiAgcmVsYXRpdmUsXG4gIGJhc2UsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBmaXJzdENoYXIgPSByZWxhdGl2ZS5jaGFyQXQoMCk7XG4gIGlmIChmaXJzdENoYXIgPT09ICcvJykge1xuICAgIHJldHVybiByZWxhdGl2ZVxuICB9XG5cbiAgaWYgKGZpcnN0Q2hhciA9PT0gJz8nIHx8IGZpcnN0Q2hhciA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVxuICB9XG5cbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xuXG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzZWdtZW50IGlmOlxuICAvLyAtIG5vdCBhcHBlbmRpbmdcbiAgLy8gLSBhcHBlbmRpbmcgdG8gdHJhaWxpbmcgc2xhc2ggKGxhc3Qgc2VnbWVudCBpcyBlbXB0eSlcbiAgaWYgKCFhcHBlbmQgfHwgIXN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcbiAgdmFyIHNlZ21lbnRzID0gcmVsYXRpdmUucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5zdXJlIGxlYWRpbmcgc2xhc2hcbiAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xuICAgIHN0YWNrLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrLmpvaW4oJy8nKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIGhhc2ggPSAnJztcbiAgdmFyIHF1ZXJ5ID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICBoYXNoID0gcGF0aC5zbGljZShoYXNoSW5kZXgpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XG4gICAgcXVlcnkgPSBwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBxdWVyeUluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKVxufVxuXG52YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG52YXIgcGF0aFRvUmVnZXhwXzEgPSBwYXRoVG9SZWdleHA7XG52YXIgcGFyc2VfMSA9IHBhcnNlO1xudmFyIGNvbXBpbGVfMSA9IGNvbXBpbGU7XG52YXIgdG9rZW5zVG9GdW5jdGlvbl8xID0gdG9rZW5zVG9GdW5jdGlvbjtcbnZhciB0b2tlbnNUb1JlZ0V4cF8xID0gdG9rZW5zVG9SZWdFeHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGtleSA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBwYXRoID0gJyc7XG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLyc7XG4gIHZhciByZXM7XG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXTtcbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXTtcbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4O1xuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGg7XG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF07XG4gICAgdmFyIHByZWZpeCA9IHJlc1syXTtcbiAgICB2YXIgbmFtZSA9IHJlc1szXTtcbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XTtcbiAgICB2YXIgZ3JvdXAgPSByZXNbNV07XG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdO1xuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XTtcblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICAgICAgcGF0aCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeDtcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXI7XG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwO1xuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleCk7XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpO1xuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJztcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlbjtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdO1xuICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXM7XG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKTtcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZTtcbiAgdmFyIHJvdXRlID0gJyc7XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpO1xuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSc7XG5cbiAgICAgIGtleXMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpO1xuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlcjtcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJztcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cbnBhdGhUb1JlZ2V4cF8xLnBhcnNlID0gcGFyc2VfMTtcbnBhdGhUb1JlZ2V4cF8xLmNvbXBpbGUgPSBjb21waWxlXzE7XG5wYXRoVG9SZWdleHBfMS50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbl8xO1xucGF0aFRvUmVnZXhwXzEudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cF8xO1xuXG4vKiAgKi9cblxuLy8gJGZsb3ctZGlzYWJsZS1saW5lXG52YXIgcmVnZXhwQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gZmlsbFBhcmFtcyAoXG4gIHBhdGgsXG4gIHBhcmFtcyxcbiAgcm91dGVNc2dcbikge1xuICB0cnkge1xuICAgIHZhciBmaWxsZXIgPVxuICAgICAgcmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdIHx8XG4gICAgICAocmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdID0gcGF0aFRvUmVnZXhwXzEuY29tcGlsZShwYXRoKSk7XG4gICAgcmV0dXJuIGZpbGxlcihwYXJhbXMgfHwge30sIHsgcHJldHR5OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgKFwibWlzc2luZyBwYXJhbSBmb3IgXCIgKyByb3V0ZU1zZyArIFwiOiBcIiArIChlLm1lc3NhZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZU1hcCAoXG4gIHJvdXRlcyxcbiAgb2xkUGF0aExpc3QsXG4gIG9sZFBhdGhNYXAsXG4gIG9sZE5hbWVNYXBcbikge1xuICAvLyB0aGUgcGF0aCBsaXN0IGlzIHVzZWQgdG8gY29udHJvbCBwYXRoIG1hdGNoaW5nIHByaW9yaXR5XG4gIHZhciBwYXRoTGlzdCA9IG9sZFBhdGhMaXN0IHx8IFtdO1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHBhdGhNYXAgPSBvbGRQYXRoTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgbmFtZU1hcCA9IG9sZE5hbWVNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgcm91dGUpO1xuICB9KTtcblxuICAvLyBlbnN1cmUgd2lsZGNhcmQgcm91dGVzIGFyZSBhbHdheXMgYXQgdGhlIGVuZFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwYXRoTGlzdFtpXSA9PT0gJyonKSB7XG4gICAgICBwYXRoTGlzdC5wdXNoKHBhdGhMaXN0LnNwbGljZShpLCAxKVswXSk7XG4gICAgICBsLS07XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTGlzdDogcGF0aExpc3QsXG4gICAgcGF0aE1hcDogcGF0aE1hcCxcbiAgICBuYW1lTWFwOiBuYW1lTWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm91dGVSZWNvcmQgKFxuICBwYXRoTGlzdCxcbiAgcGF0aE1hcCxcbiAgbmFtZU1hcCxcbiAgcm91dGUsXG4gIHBhcmVudCxcbiAgbWF0Y2hBc1xuKSB7XG4gIHZhciBwYXRoID0gcm91dGUucGF0aDtcbiAgdmFyIG5hbWUgPSByb3V0ZS5uYW1lO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChwYXRoICE9IG51bGwsIFwiXFxcInBhdGhcXFwiIGlzIHJlcXVpcmVkIGluIGEgcm91dGUgY29uZmlndXJhdGlvbi5cIik7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXG4gICAgICBcInJvdXRlIGNvbmZpZyBcXFwiY29tcG9uZW50XFxcIiBmb3IgcGF0aDogXCIgKyAoU3RyaW5nKHBhdGggfHwgbmFtZSkpICsgXCIgY2Fubm90IGJlIGEgXCIgK1xuICAgICAgXCJzdHJpbmcgaWQuIFVzZSBhbiBhY3R1YWwgY29tcG9uZW50IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIHBhdGhUb1JlZ2V4cE9wdGlvbnMgPSByb3V0ZS5wYXRoVG9SZWdleHBPcHRpb25zIHx8IHt9O1xuICB2YXIgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKFxuICAgIHBhdGgsXG4gICAgcGFyZW50LFxuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc3RyaWN0XG4gICk7XG5cbiAgaWYgKHR5cGVvZiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSAnYm9vbGVhbicpIHtcbiAgICBwYXRoVG9SZWdleHBPcHRpb25zLnNlbnNpdGl2ZSA9IHJvdXRlLmNhc2VTZW5zaXRpdmU7XG4gIH1cblxuICB2YXIgcmVjb3JkID0ge1xuICAgIHBhdGg6IG5vcm1hbGl6ZWRQYXRoLFxuICAgIHJlZ2V4OiBjb21waWxlUm91dGVSZWdleChub3JtYWxpemVkUGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucyksXG4gICAgY29tcG9uZW50czogcm91dGUuY29tcG9uZW50cyB8fCB7IGRlZmF1bHQ6IHJvdXRlLmNvbXBvbmVudCB9LFxuICAgIGluc3RhbmNlczoge30sXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcbiAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcbiAgICBwcm9wczogcm91dGUucHJvcHMgPT0gbnVsbFxuICAgICAgPyB7fVxuICAgICAgOiByb3V0ZS5jb21wb25lbnRzXG4gICAgICAgID8gcm91dGUucHJvcHNcbiAgICAgICAgOiB7IGRlZmF1bHQ6IHJvdXRlLnByb3BzIH1cbiAgfTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkLCBkb2VzIG5vdCByZWRpcmVjdCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChyb3V0ZS5uYW1lICYmICFyb3V0ZS5yZWRpcmVjdCAmJiByb3V0ZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gL15cXC8/JC8udGVzdChjaGlsZC5wYXRoKTsgfSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIk5hbWVkIFJvdXRlICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJyBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLiBcIiArXG4gICAgICAgICAgXCJXaGVuIG5hdmlnYXRpbmcgdG8gdGhpcyBuYW1lZCByb3V0ZSAoOnRvPVxcXCJ7bmFtZTogJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInXFxcIiksIFwiICtcbiAgICAgICAgICBcInRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBSZW1vdmUgdGhlIG5hbWUgZnJvbSBcIiArXG4gICAgICAgICAgXCJ0aGlzIHJvdXRlIGFuZCB1c2UgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgZm9yIG5hbWVkIFwiICtcbiAgICAgICAgICBcImxpbmtzIGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE1hdGNoQXMgPSBtYXRjaEFzXG4gICAgICAgID8gY2xlYW5QYXRoKChtYXRjaEFzICsgXCIvXCIgKyAoY2hpbGQucGF0aCkpKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCBjaGlsZCwgcmVjb3JkLCBjaGlsZE1hdGNoQXMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJvdXRlLmFsaWFzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgYWxpYXNlcyA9IEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpXG4gICAgICA/IHJvdXRlLmFsaWFzXG4gICAgICA6IFtyb3V0ZS5hbGlhc107XG5cbiAgICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgcGF0aDogYWxpYXMsXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlblxuICAgICAgfTtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKFxuICAgICAgICBwYXRoTGlzdCxcbiAgICAgICAgcGF0aE1hcCxcbiAgICAgICAgbmFtZU1hcCxcbiAgICAgICAgYWxpYXNSb3V0ZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICByZWNvcmQucGF0aCB8fCAnLycgLy8gbWF0Y2hBc1xuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghcGF0aE1hcFtyZWNvcmQucGF0aF0pIHtcbiAgICBwYXRoTGlzdC5wdXNoKHJlY29yZC5wYXRoKTtcbiAgICBwYXRoTWFwW3JlY29yZC5wYXRoXSA9IHJlY29yZDtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgaWYgKCFuYW1lTWFwW25hbWVdKSB7XG4gICAgICBuYW1lTWFwW25hbWVdID0gcmVjb3JkO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbWF0Y2hBcykge1xuICAgICAgd2FybihcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiRHVwbGljYXRlIG5hbWVkIHJvdXRlcyBkZWZpbml0aW9uOiBcIiArXG4gICAgICAgIFwieyBuYW1lOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBwYXRoOiBcXFwiXCIgKyAocmVjb3JkLnBhdGgpICsgXCJcXFwiIH1cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVJvdXRlUmVnZXggKHBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpIHtcbiAgdmFyIHJlZ2V4ID0gcGF0aFRvUmVnZXhwXzEocGF0aCwgW10sIHBhdGhUb1JlZ2V4cE9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZWdleC5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgd2Fybigha2V5c1trZXkubmFtZV0sIChcIkR1cGxpY2F0ZSBwYXJhbSBrZXlzIGluIHJvdXRlIHdpdGggcGF0aDogXFxcIlwiICsgcGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICBrZXlzW2tleS5uYW1lXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2V4XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCwgc3RyaWN0KSB7XG4gIGlmICghc3RyaWN0KSB7IHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7IH1cbiAgaWYgKHBhdGhbMF0gPT09ICcvJykgeyByZXR1cm4gcGF0aCB9XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gcGF0aCB9XG4gIHJldHVybiBjbGVhblBhdGgoKChwYXJlbnQucGF0aCkgKyBcIi9cIiArIHBhdGgpKVxufVxuXG4vKiAgKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbiAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgYXBwZW5kLFxuICByb3V0ZXJcbikge1xuICB2YXIgbmV4dCA9IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnID8geyBwYXRoOiByYXcgfSA6IHJhdztcbiAgLy8gbmFtZWQgdGFyZ2V0XG4gIGlmIChuZXh0Lm5hbWUgfHwgbmV4dC5fbm9ybWFsaXplZCkge1xuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvLyByZWxhdGl2ZSBwYXJhbXNcbiAgaWYgKCFuZXh0LnBhdGggJiYgbmV4dC5wYXJhbXMgJiYgY3VycmVudCkge1xuICAgIG5leHQgPSBhc3NpZ24oe30sIG5leHQpO1xuICAgIG5leHQuX25vcm1hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBwYXJhbXMgPSBhc3NpZ24oYXNzaWduKHt9LCBjdXJyZW50LnBhcmFtcyksIG5leHQucGFyYW1zKTtcbiAgICBpZiAoY3VycmVudC5uYW1lKSB7XG4gICAgICBuZXh0Lm5hbWUgPSBjdXJyZW50Lm5hbWU7XG4gICAgICBuZXh0LnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZC5sZW5ndGgpIHtcbiAgICAgIHZhciByYXdQYXRoID0gY3VycmVudC5tYXRjaGVkW2N1cnJlbnQubWF0Y2hlZC5sZW5ndGggLSAxXS5wYXRoO1xuICAgICAgbmV4dC5wYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInBhdGggXCIgKyAoY3VycmVudC5wYXRoKSkpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgXCJyZWxhdGl2ZSBwYXJhbXMgbmF2aWdhdGlvbiByZXF1aXJlcyBhIGN1cnJlbnQgcm91dGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgdmFyIHBhcnNlZFBhdGggPSBwYXJzZVBhdGgobmV4dC5wYXRoIHx8ICcnKTtcbiAgdmFyIGJhc2VQYXRoID0gKGN1cnJlbnQgJiYgY3VycmVudC5wYXRoKSB8fCAnLyc7XG4gIHZhciBwYXRoID0gcGFyc2VkUGF0aC5wYXRoXG4gICAgPyByZXNvbHZlUGF0aChwYXJzZWRQYXRoLnBhdGgsIGJhc2VQYXRoLCBhcHBlbmQgfHwgbmV4dC5hcHBlbmQpXG4gICAgOiBiYXNlUGF0aDtcblxuICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkoXG4gICAgcGFyc2VkUGF0aC5xdWVyeSxcbiAgICBuZXh0LnF1ZXJ5LFxuICAgIHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5wYXJzZVF1ZXJ5XG4gICk7XG5cbiAgdmFyIGhhc2ggPSBuZXh0Lmhhc2ggfHwgcGFyc2VkUGF0aC5oYXNoO1xuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiAoYSwgYikge1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGFba2V5XSA9IGJba2V5XTtcbiAgfVxuICByZXR1cm4gYVxufVxuXG4vKiAgKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaGVyIChcbiAgcm91dGVzLFxuICByb3V0ZXJcbikge1xuICB2YXIgcmVmID0gY3JlYXRlUm91dGVNYXAocm91dGVzKTtcbiAgdmFyIHBhdGhMaXN0ID0gcmVmLnBhdGhMaXN0O1xuICB2YXIgcGF0aE1hcCA9IHJlZi5wYXRoTWFwO1xuICB2YXIgbmFtZU1hcCA9IHJlZi5uYW1lTWFwO1xuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gICAgY3JlYXRlUm91dGVNYXAocm91dGVzLCBwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCAoXG4gICAgcmF3LFxuICAgIGN1cnJlbnRSb3V0ZSxcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSwgZmFsc2UsIHJvdXRlcik7XG4gICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVjb3JkKSB7IHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gcmVjb3JkLnJlZ2V4LmtleXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAha2V5Lm9wdGlvbmFsOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5uYW1lOyB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbi5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFJvdXRlICYmIHR5cGVvZiBjdXJyZW50Um91dGUucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJvdXRlLnBhcmFtcykge1xuICAgICAgICAgIGlmICghKGtleSBpbiBsb2NhdGlvbi5wYXJhbXMpICYmIHBhcmFtTmFtZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtc1trZXldID0gY3VycmVudFJvdXRlLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhdGggPSBmaWxsUGFyYW1zKHJlY29yZC5wYXRoLCBsb2NhdGlvbi5wYXJhbXMsIChcIm5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aCkge1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aExpc3RbaV07XG4gICAgICAgIHZhciByZWNvcmQkMSA9IHBhdGhNYXBbcGF0aF07XG4gICAgICAgIGlmIChtYXRjaFJvdXRlKHJlY29yZCQxLnJlZ2V4LCBsb2NhdGlvbi5wYXRoLCBsb2NhdGlvbi5wYXJhbXMpKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQkMSwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vIG1hdGNoXG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZGlyZWN0IChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb25cbiAgKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVkaXJlY3QgPSByZWNvcmQucmVkaXJlY3Q7XG4gICAgdmFyIHJlZGlyZWN0ID0gdHlwZW9mIG9yaWdpbmFsUmVkaXJlY3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcmlnaW5hbFJlZGlyZWN0KGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcikpXG4gICAgICAgIDogb3JpZ2luYWxSZWRpcmVjdDtcblxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWRpcmVjdCA9IHsgcGF0aDogcmVkaXJlY3QgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZGlyZWN0IHx8IHR5cGVvZiByZWRpcmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG5cbiAgICB2YXIgcmUgPSByZWRpcmVjdDtcbiAgICB2YXIgbmFtZSA9IHJlLm5hbWU7XG4gICAgdmFyIHBhdGggPSByZS5wYXRoO1xuICAgIHZhciBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgcGFyYW1zID0gbG9jYXRpb24ucGFyYW1zO1xuICAgIHF1ZXJ5ID0gcmUuaGFzT3duUHJvcGVydHkoJ3F1ZXJ5JykgPyByZS5xdWVyeSA6IHF1ZXJ5O1xuICAgIGhhc2ggPSByZS5oYXNPd25Qcm9wZXJ0eSgnaGFzaCcpID8gcmUuaGFzaCA6IGhhc2g7XG4gICAgcGFyYW1zID0gcmUuaGFzT3duUHJvcGVydHkoJ3BhcmFtcycpID8gcmUucGFyYW1zIDogcGFyYW1zO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIC8vIHJlc29sdmVkIG5hbWVkIGRpcmVjdFxuICAgICAgdmFyIHRhcmdldFJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQodGFyZ2V0UmVjb3JkLCAoXCJyZWRpcmVjdCBmYWlsZWQ6IG5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2UgaWYgKHBhdGgpIHtcbiAgICAgIC8vIDEuIHJlc29sdmUgcmVsYXRpdmUgcmVkaXJlY3RcbiAgICAgIHZhciByYXdQYXRoID0gcmVzb2x2ZVJlY29yZFBhdGgocGF0aCwgcmVjb3JkKTtcbiAgICAgIC8vIDIuIHJlc29sdmUgcGFyYW1zXG4gICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInJlZGlyZWN0IHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyByYXdQYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIC8vIDMuIHJlbWF0Y2ggd2l0aCBleGlzdGluZyBxdWVyeSBhbmQgaGFzaFxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIHBhdGg6IHJlc29sdmVkUGF0aCxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGlhcyAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIG1hdGNoQXNcbiAgKSB7XG4gICAgdmFyIGFsaWFzZWRQYXRoID0gZmlsbFBhcmFtcyhtYXRjaEFzLCBsb2NhdGlvbi5wYXJhbXMsIChcImFsaWFzZWQgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIG1hdGNoQXMgKyBcIlxcXCJcIikpO1xuICAgIHZhciBhbGlhc2VkTWF0Y2ggPSBtYXRjaCh7XG4gICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgIHBhdGg6IGFsaWFzZWRQYXRoXG4gICAgfSk7XG4gICAgaWYgKGFsaWFzZWRNYXRjaCkge1xuICAgICAgdmFyIG1hdGNoZWQgPSBhbGlhc2VkTWF0Y2gubWF0Y2hlZDtcbiAgICAgIHZhciBhbGlhc2VkUmVjb3JkID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdO1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0gYWxpYXNlZE1hdGNoLnBhcmFtcztcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUoYWxpYXNlZFJlY29yZCwgbG9jYXRpb24pXG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlUm91dGUgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5yZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlZGlyZWN0KHJlY29yZCwgcmVkaXJlY3RlZEZyb20gfHwgbG9jYXRpb24pXG4gICAgfVxuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLm1hdGNoQXMpIHtcbiAgICAgIHJldHVybiBhbGlhcyhyZWNvcmQsIGxvY2F0aW9uLCByZWNvcmQubWF0Y2hBcylcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tLCByb3V0ZXIpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBhZGRSb3V0ZXM6IGFkZFJvdXRlc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGUgKFxuICByZWdleCxcbiAgcGF0aCxcbiAgcGFyYW1zXG4pIHtcbiAgdmFyIG0gPSBwYXRoLm1hdGNoKHJlZ2V4KTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IHJlZ2V4LmtleXNbaSAtIDFdO1xuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cblxudmFyIHBvc2l0aW9uU3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XG4gIC8vIEZpeCBmb3IgIzE1ODUgZm9yIEZpcmVmb3hcbiAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBnZXRTdGF0ZUtleSgpIH0sICcnKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXG4gIHJvdXRlcixcbiAgdG8sXG4gIGZyb20sXG4gIGlzUG9wXG4pIHtcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgaWYgKCFiZWhhdmlvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJlaGF2aW9yID09PSAnZnVuY3Rpb24nLCBcInNjcm9sbEJlaGF2aW9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIC8vIHdhaXQgdW50aWwgcmUtcmVuZGVyIGZpbmlzaGVzIGJlZm9yZSBzY3JvbGxpbmdcbiAgcm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgdmFyIHNob3VsZFNjcm9sbCA9IGJlaGF2aW9yKHRvLCBmcm9tLCBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbCk7XG5cbiAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzaG91bGRTY3JvbGwudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2hvdWxkU2Nyb2xsLnRoZW4oZnVuY3Rpb24gKHNob3VsZFNjcm9sbCkge1xuICAgICAgICBzY3JvbGxUb1Bvc2l0aW9uKChzaG91bGRTY3JvbGwpLCBwb3NpdGlvbik7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxUb1Bvc2l0aW9uKHNob3VsZFNjcm9sbCwgcG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcG9zaXRpb25TdG9yZVtrZXldID0ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbiAoZWwsIG9mZnNldCkge1xuICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBkb2NSZWN0ID0gZG9jRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbFJlY3QubGVmdCAtIGRvY1JlY3QubGVmdCAtIG9mZnNldC54LFxuICAgIHk6IGVsUmVjdC50b3AgLSBkb2NSZWN0LnRvcCAtIG9mZnNldC55XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT2Zmc2V0IChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IDAsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiAwXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uIChzaG91bGRTY3JvbGwsIHBvc2l0aW9uKSB7XG4gIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnO1xuICBpZiAoaXNPYmplY3QgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XG4gICAgaWYgKGVsKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gc2hvdWxkU2Nyb2xsLm9mZnNldCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLm9mZnNldCA9PT0gJ29iamVjdCcgPyBzaG91bGRTY3JvbGwub2Zmc2V0IDoge307XG4gICAgICBvZmZzZXQgPSBub3JtYWxpemVPZmZzZXQob2Zmc2V0KTtcbiAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsLCBvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QgJiYgaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gIH1cblxuICBpZiAocG9zaXRpb24pIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IGluQnJvd3NlciAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoXG4gICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnlcbn0pKCk7XG5cbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cbnZhciBUaW1lID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlXG4gIDogRGF0ZTtcblxudmFyIF9rZXkgPSBnZW5LZXkoKTtcblxuZnVuY3Rpb24gZ2VuS2V5ICgpIHtcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XG4gIHJldHVybiBfa2V5XG59XG5cbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcbiAgX2tleSA9IGtleTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlICh1cmwsIHJlcGxhY2UpIHtcbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gIC8vIHRyeS4uLmNhdGNoIHRoZSBwdXNoU3RhdGUgY2FsbCB0byBnZXQgYXJvdW5kIFNhZmFyaVxuICAvLyBET00gRXhjZXB0aW9uIDE4IHdoZXJlIGl0IGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5ID0gZ2VuS2V5KCk7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyAobWF0Y2hlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgdmFyIGhhc0FzeW5jID0gZmFsc2U7XG4gICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24gYW5kIGRvZXNuJ3QgaGF2ZSBjaWQgYXR0YWNoZWQsXG4gICAgICAvLyBhc3N1bWUgaXQncyBhbiBhc3luYyBjb21wb25lbnQgcmVzb2x2ZSBmdW5jdGlvbi5cbiAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgVnVlJ3MgZGVmYXVsdCBhc3luYyByZXNvbHZpbmcgbWVjaGFuaXNtIGJlY2F1c2VcbiAgICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAvLyByZXNvbHZlZC5cbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGRlZi5jaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoYXNBc3luYyA9IHRydWU7XG4gICAgICAgIHBlbmRpbmcrKztcblxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlc29sdmVkRGVmKSB7XG4gICAgICAgICAgaWYgKGlzRVNNb2R1bGUocmVzb2x2ZWREZWYpKSB7XG4gICAgICAgICAgICByZXNvbHZlZERlZiA9IHJlc29sdmVkRGVmLmRlZmF1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNhdmUgcmVzb2x2ZWQgb24gYXN5bmMgZmFjdG9yeSBpbiBjYXNlIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICAgICAgICBkZWYucmVzb2x2ZWQgPSB0eXBlb2YgcmVzb2x2ZWREZWYgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcmVzb2x2ZWREZWZcbiAgICAgICAgICAgIDogX1Z1ZS5leHRlbmQocmVzb2x2ZWREZWYpO1xuICAgICAgICAgIG1hdGNoLmNvbXBvbmVudHNba2V5XSA9IHJlc29sdmVkRGVmO1xuICAgICAgICAgIHBlbmRpbmctLTtcbiAgICAgICAgICBpZiAocGVuZGluZyA8PSAwKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50IFwiICsga2V5ICsgXCI6IFwiICsgcmVhc29uO1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgbXNnKTtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGlzRXJyb3IocmVhc29uKVxuICAgICAgICAgICAgICA/IHJlYXNvblxuICAgICAgICAgICAgICA6IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBuZXcgc3ludGF4IGluIFZ1ZSAyLjNcbiAgICAgICAgICAgIHZhciBjb21wID0gcmVzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wICYmIHR5cGVvZiBjb21wLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY29tcC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWhhc0FzeW5jKSB7IG5leHQoKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbmZ1bmN0aW9uIGlzRVNNb2R1bGUgKG9iaikge1xuICByZXR1cm4gb2JqLl9fZXNNb2R1bGUgfHwgKGhhc1N5bWJvbCAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG59XG5cbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2Vcbi8vIHNvIHRoZSByZXNvbHZlL3JlamVjdCBmdW5jdGlvbnMgbWF5IGdldCBjYWxsZWQgYW4gZXh0cmEgdGltZVxuLy8gaWYgdGhlIHVzZXIgdXNlcyBhbiBhcnJvdyBmdW5jdGlvbiBzaG9ydGhhbmQgdGhhdCBoYXBwZW5zIHRvXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGlmIChjYWxsZWQpIHsgcmV0dXJuIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgdGhpcy5iYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcbiAgdGhpcy5jdXJyZW50ID0gU1RBUlQ7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5yZWFkeUNicyA9IFtdO1xuICB0aGlzLnJlYWR5RXJyb3JDYnMgPSBbXTtcbiAgdGhpcy5lcnJvckNicyA9IFtdO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xuICB0aGlzLmNiID0gY2I7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICBjYigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVhZHlDYnMucHVzaChjYik7XG4gICAgaWYgKGVycm9yQ2IpIHtcbiAgICAgIHRoaXMucmVhZHlFcnJvckNicy5wdXNoKGVycm9yQ2IpO1xuICAgIH1cbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5lcnJvckNicy5wdXNoKGVycm9yQ2IpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcblxuICAgIC8vIGZpcmUgcmVhZHkgY2JzIG9uY2VcbiAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihyb3V0ZSk7IH0pO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChvbkFib3J0KSB7XG4gICAgICBvbkFib3J0KGVycik7XG4gICAgfVxuICAgIGlmIChlcnIgJiYgIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5jb25maXJtVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uIChyb3V0ZSwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGlzRXJyb3IoZXJyKSkge1xuICAgICAgaWYgKHRoaXMkMS5lcnJvckNicy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcyQxLmVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihmYWxzZSwgJ3VuY2F1Z2h0IGVycm9yIGR1cmluZyByb3V0ZSBuYXZpZ2F0aW9uOicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQWJvcnQgJiYgb25BYm9ydChlcnIpO1xuICB9O1xuICBpZiAoXG4gICAgaXNTYW1lUm91dGUocm91dGUsIGN1cnJlbnQpICYmXG4gICAgLy8gaW4gdGhlIGNhc2UgdGhlIHJvdXRlIG1hcCBoYXMgYmVlbiBkeW5hbWljYWxseSBhcHBlbmRlZCB0b1xuICAgIHJvdXRlLm1hdGNoZWQubGVuZ3RoID09PSBjdXJyZW50Lm1hdGNoZWQubGVuZ3RoXG4gICkge1xuICAgIHRoaXMuZW5zdXJlVVJMKCk7XG4gICAgcmV0dXJuIGFib3J0KClcbiAgfVxuXG4gIHZhciByZWYgPSByZXNvbHZlUXVldWUodGhpcy5jdXJyZW50Lm1hdGNoZWQsIHJvdXRlLm1hdGNoZWQpO1xuICAgIHZhciB1cGRhdGVkID0gcmVmLnVwZGF0ZWQ7XG4gICAgdmFyIGRlYWN0aXZhdGVkID0gcmVmLmRlYWN0aXZhdGVkO1xuICAgIHZhciBhY3RpdmF0ZWQgPSByZWYuYWN0aXZhdGVkO1xuXG4gIHZhciBxdWV1ZSA9IFtdLmNvbmNhdChcbiAgICAvLyBpbi1jb21wb25lbnQgbGVhdmUgZ3VhcmRzXG4gICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcbiAgICAvLyBnbG9iYWwgYmVmb3JlIGhvb2tzXG4gICAgdGhpcy5yb3V0ZXIuYmVmb3JlSG9va3MsXG4gICAgLy8gaW4tY29tcG9uZW50IHVwZGF0ZSBob29rc1xuICAgIGV4dHJhY3RVcGRhdGVIb29rcyh1cGRhdGVkKSxcbiAgICAvLyBpbi1jb25maWcgZW50ZXIgZ3VhcmRzXG4gICAgYWN0aXZhdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5iZWZvcmVFbnRlcjsgfSksXG4gICAgLy8gYXN5bmMgY29tcG9uZW50c1xuICAgIHJlc29sdmVBc3luY0NvbXBvbmVudHMoYWN0aXZhdGVkKVxuICApO1xuXG4gIHRoaXMucGVuZGluZyA9IHJvdXRlO1xuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xuICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBob29rKHJvdXRlLCBjdXJyZW50LCBmdW5jdGlvbiAodG8pIHtcbiAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc0Vycm9yKHRvKSkge1xuICAgICAgICAgIC8vIG5leHQoZmFsc2UpIC0+IGFib3J0IG5hdmlnYXRpb24sIGVuc3VyZSBjdXJyZW50IFVSTFxuICAgICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgICAgYWJvcnQodG8pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiAoXG4gICAgICAgICAgICB0eXBlb2YgdG8ucGF0aCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0by5uYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5leHQoJy8nKSBvciBuZXh0KHsgcGF0aDogJy8nIH0pIC0+IHJlZGlyZWN0XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzJDEucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uZmlybSB0cmFuc2l0aW9uIGFuZCBwYXNzIG9uIHRoZSB2YWx1ZVxuICAgICAgICAgIG5leHQodG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydChlKTtcbiAgICB9XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIC8vIHdhaXQgdW50aWwgYXN5bmMgY29tcG9uZW50cyBhcmUgcmVzb2x2ZWQgYmVmb3JlXG4gICAgLy8gZXh0cmFjdGluZyBpbi1jb21wb25lbnQgZW50ZXIgZ3VhcmRzXG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcbiAgICB2YXIgcXVldWUgPSBlbnRlckd1YXJkcy5jb25jYXQodGhpcyQxLnJvdXRlci5yZXNvbHZlSG9va3MpO1xuICAgIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gYWJvcnQoKVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xuICAgICAgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICBpZiAodGhpcyQxLnJvdXRlci5hcHApIHtcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwb3N0RW50ZXJDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZVJvdXRlID0gZnVuY3Rpb24gdXBkYXRlUm91dGUgKHJvdXRlKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xuICB0aGlzLmN1cnJlbnQgPSByb3V0ZTtcbiAgdGhpcy5jYiAmJiB0aGlzLmNiKHJvdXRlKTtcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vayAmJiBob29rKHJvdXRlLCBwcmV2KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVCYXNlIChiYXNlKSB7XG4gIGlmICghYmFzZSkge1xuICAgIGlmIChpbkJyb3dzZXIpIHtcbiAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICAgIGJhc2UgPSAoYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJy8nO1xuICAgICAgLy8gc3RyaXAgZnVsbCBVUkwgb3JpZ2luXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teXFwvXSsvLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgICAgcmV0dXJuIGd1YXJkLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVFbnRlcicsIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBuZXh0KGNiKTtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICM3NTBcbiAgICAgICAgICAvLyBpZiBhIHJvdXRlci12aWV3IGlzIHdyYXBwZWQgd2l0aCBhbiBvdXQtaW4gdHJhbnNpdGlvbixcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHBvbGwgZm9yIHJlZ2lzdHJhdGlvbiB1bnRpbCBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgLy8gaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKGluc3RhbmNlc1trZXldKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcblxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRMb2NhdGlvbiA9IGdldExvY2F0aW9uKHRoaXMuYmFzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnQ7XG5cbiAgICAgIC8vIEF2b2lkaW5nIGZpcnN0IGBwb3BzdGF0ZWAgZXZlbnQgZGlzcGF0Y2hlZCBpbiBzb21lIGJyb3dzZXJzIGJ1dCBmaXJzdFxuICAgICAgLy8gaGlzdG9yeSByb3V0ZSBub3QgdXBkYXRlZCBzaW5jZSBhc3luYyBndWFyZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpO1xuICAgICAgaWYgKHRoaXMkMS5jdXJyZW50ID09PSBTVEFSVCAmJiBsb2NhdGlvbiA9PT0gaW5pdExvY2F0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbChyb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIVE1MNUhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhUTUw1SGlzdG9yeTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgaWYgKGdldExvY2F0aW9uKHRoaXMuYmFzZSkgIT09IHRoaXMuY3VycmVudC5mdWxsUGF0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjbGVhblBhdGgodGhpcy5iYXNlICsgdGhpcy5jdXJyZW50LmZ1bGxQYXRoKTtcbiAgICAgIHB1c2ggPyBwdXNoU3RhdGUoY3VycmVudCkgOiByZXBsYWNlU3RhdGUoY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxuICB9O1xuXG4gIHJldHVybiBIVE1MNUhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGJhc2UpIHtcbiAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxufVxuXG4vKiAgKi9cblxuXG52YXIgSGFzaEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkgKHJvdXRlciwgYmFzZSwgZmFsbGJhY2spIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICAvLyBjaGVjayBoaXN0b3J5IGZhbGxiYWNrIGRlZXBsaW5raW5nXG4gICAgaWYgKGZhbGxiYWNrICYmIGNoZWNrRmFsbGJhY2sodGhpcy5iYXNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVuc3VyZVNsYXNoKCk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIYXNoSGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hIaXN0b3J5O1xuXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xuICAvLyB0byBhdm9pZCB0aGUgaGFzaGNoYW5nZSBsaXN0ZW5lciBiZWluZyBmaXJlZCB0b28gZWFybHlcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnNldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMucm91dGVyO1xuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgICB2YXIgc3VwcG9ydHNTY3JvbGwgPSBzdXBwb3J0c1B1c2hTdGF0ZSAmJiBleHBlY3RTY3JvbGw7XG5cbiAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoc3VwcG9ydHNQdXNoU3RhdGUgPyAncG9wc3RhdGUnIDogJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuZnVsbFBhdGg7XG4gICAgaWYgKGdldEhhc2goKSAhPT0gY3VycmVudCkge1xuICAgICAgcHVzaCA/IHB1c2hIYXNoKGN1cnJlbnQpIDogcmVwbGFjZUhhc2goY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRIYXNoKClcbiAgfTtcblxuICByZXR1cm4gSGFzaEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gY2hlY2tGYWxsYmFjayAoYmFzZSkge1xuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihiYXNlKTtcbiAgaWYgKCEvXlxcLyMvLnRlc3QobG9jYXRpb24pKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG4gICAgICBjbGVhblBhdGgoYmFzZSArICcvIycgKyBsb2NhdGlvbilcbiAgICApO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlU2xhc2ggKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2goKTtcbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJlcGxhY2VIYXNoKCcvJyArIHBhdGgpO1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2V0SGFzaCAoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc2xpY2UoaW5kZXggKyAxKVxufVxuXG5mdW5jdGlvbiBnZXRVcmwgKHBhdGgpIHtcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGkgPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgdmFyIGJhc2UgPSBpID49IDAgPyBocmVmLnNsaWNlKDAsIGkpIDogaHJlZjtcbiAgcmV0dXJuIChiYXNlICsgXCIjXCIgKyBwYXRoKVxufVxuXG5mdW5jdGlvbiBwdXNoSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICBwdXNoU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcbiAgaWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgcmVwbGFjZVN0YXRlKGdldFVybChwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoZ2V0VXJsKHBhdGgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEFic3RyYWN0SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RIaXN0b3J5O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcbiAgICAgIHRoaXMkMS5pbmRleCsrO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCkuY29uY2F0KHJvdXRlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHJvdXRlID0gdGhpcy5zdGFja1t0YXJnZXRJbmRleF07XG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmluZGV4ID0gdGFyZ2V0SW5kZXg7XG4gICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZnVsbFBhdGggOiAnLydcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuLyogICovXG5cbnZhciBWdWVSb3V0ZXIgPSBmdW5jdGlvbiBWdWVSb3V0ZXIgKG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5hcHAgPSBudWxsO1xuICB0aGlzLmFwcHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5iZWZvcmVIb29rcyA9IFtdO1xuICB0aGlzLnJlc29sdmVIb29rcyA9IFtdO1xuICB0aGlzLmFmdGVySG9va3MgPSBbXTtcbiAgdGhpcy5tYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihvcHRpb25zLnJvdXRlcyB8fCBbXSwgdGhpcyk7XG5cbiAgdmFyIG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ2hhc2gnO1xuICB0aGlzLmZhbGxiYWNrID0gbW9kZSA9PT0gJ2hpc3RvcnknICYmICFzdXBwb3J0c1B1c2hTdGF0ZSAmJiBvcHRpb25zLmZhbGxiYWNrICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICBtb2RlID0gJ2hhc2gnO1xuICB9XG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgbW9kZSA9ICdhYnN0cmFjdCc7XG4gIH1cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdoaXN0b3J5JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIVE1MNUhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGFzaEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlLCB0aGlzLmZhbGxiYWNrKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEFic3RyYWN0SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAoXCJpbnZhbGlkIG1vZGU6IFwiICsgbW9kZSkpO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjdXJyZW50Um91dGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICByZWRpcmVjdGVkRnJvbVxuKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoZXIubWF0Y2gocmF3LCBjdXJyZW50LCByZWRpcmVjdGVkRnJvbSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5jdXJyZW50Um91dGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5jdXJyZW50XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChhcHAgLyogVnVlIGNvbXBvbmVudCBpbnN0YW5jZSAqLykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0KFxuICAgIGluc3RhbGwuaW5zdGFsbGVkLFxuICAgIFwibm90IGluc3RhbGxlZC4gTWFrZSBzdXJlIHRvIGNhbGwgYFZ1ZS51c2UoVnVlUm91dGVyKWAgXCIgK1xuICAgIFwiYmVmb3JlIGNyZWF0aW5nIHJvb3QgaW5zdGFuY2UuXCJcbiAgKTtcblxuICB0aGlzLmFwcHMucHVzaChhcHApO1xuXG4gIC8vIG1haW4gYXBwIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gIGlmICh0aGlzLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5hcHAgPSBhcHA7XG5cbiAgdmFyIGhpc3RvcnkgPSB0aGlzLmhpc3Rvcnk7XG5cbiAgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIVE1MNUhpc3RvcnkpIHtcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfSBlbHNlIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSGFzaEhpc3RvcnkpIHtcbiAgICB2YXIgc2V0dXBIYXNoTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBoaXN0b3J5LnNldHVwTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhcbiAgICAgIGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCksXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lcixcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyXG4gICAgKTtcbiAgfVxuXG4gIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIHRoaXMkMS5hcHBzLmZvckVhY2goZnVuY3Rpb24gKGFwcCkge1xuICAgICAgYXBwLl9yb3V0ZSA9IHJvdXRlO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uIGJlZm9yZUVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5iZWZvcmVIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZVJlc29sdmUgPSBmdW5jdGlvbiBiZWZvcmVSZXNvbHZlIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMucmVzb2x2ZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYWZ0ZXJIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xuICB0aGlzLmhpc3Rvcnkub25SZWFkeShjYiwgZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vbkVycm9yKGVycm9yQ2IpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgdGhpcy5oaXN0b3J5LnB1c2gobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgdGhpcy5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gIHRoaXMuaGlzdG9yeS5nbyhuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uIGJhY2sgKCkge1xuICB0aGlzLmdvKC0xKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKCkge1xuICB0aGlzLmdvKDEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nZXRNYXRjaGVkQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGdldE1hdGNoZWRDb21wb25lbnRzICh0bykge1xuICB2YXIgcm91dGUgPSB0b1xuICAgID8gdG8ubWF0Y2hlZFxuICAgICAgPyB0b1xuICAgICAgOiB0aGlzLnJlc29sdmUodG8pLnJvdXRlXG4gICAgOiB0aGlzLmN1cnJlbnRSb3V0ZTtcbiAgaWYgKCFyb3V0ZSkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIHJvdXRlLm1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBtLmNvbXBvbmVudHNba2V5XVxuICAgIH0pXG4gIH0pKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoXG4gIHRvLFxuICBjdXJyZW50LFxuICBhcHBlbmRcbikge1xuICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihcbiAgICB0byxcbiAgICBjdXJyZW50IHx8IHRoaXMuaGlzdG9yeS5jdXJyZW50LFxuICAgIGFwcGVuZCxcbiAgICB0aGlzXG4gICk7XG4gIHZhciByb3V0ZSA9IHRoaXMubWF0Y2gobG9jYXRpb24sIGN1cnJlbnQpO1xuICB2YXIgZnVsbFBhdGggPSByb3V0ZS5yZWRpcmVjdGVkRnJvbSB8fCByb3V0ZS5mdWxsUGF0aDtcbiAgdmFyIGJhc2UgPSB0aGlzLmhpc3RvcnkuYmFzZTtcbiAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGJhc2UsIGZ1bGxQYXRoLCB0aGlzLm1vZGUpO1xuICByZXR1cm4ge1xuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICByb3V0ZTogcm91dGUsXG4gICAgaHJlZjogaHJlZixcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIG5vcm1hbGl6ZWRUbzogbG9jYXRpb24sXG4gICAgcmVzb2x2ZWQ6IHJvdXRlXG4gIH1cbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWRkUm91dGVzID0gZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgdGhpcy5tYXRjaGVyLmFkZFJvdXRlcyhyb3V0ZXMpO1xuICBpZiAodGhpcy5oaXN0b3J5LmN1cnJlbnQgIT09IFNUQVJUKSB7XG4gICAgdGhpcy5oaXN0b3J5LnRyYW5zaXRpb25Ubyh0aGlzLmhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVnVlUm91dGVyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVySG9vayAobGlzdCwgZm4pIHtcbiAgbGlzdC5wdXNoKGZuKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IGxpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGkgPiAtMSkgeyBsaXN0LnNwbGljZShpLCAxKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhyZWYgKGJhc2UsIGZ1bGxQYXRoLCBtb2RlKSB7XG4gIHZhciBwYXRoID0gbW9kZSA9PT0gJ2hhc2gnID8gJyMnICsgZnVsbFBhdGggOiBmdWxsUGF0aDtcbiAgcmV0dXJuIGJhc2UgPyBjbGVhblBhdGgoYmFzZSArICcvJyArIHBhdGgpIDogcGF0aFxufVxuXG5WdWVSb3V0ZXIuaW5zdGFsbCA9IGluc3RhbGw7XG5WdWVSb3V0ZXIudmVyc2lvbiA9ICcyLjguMSc7XG5cbmlmIChpbkJyb3dzZXIgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShWdWVSb3V0ZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBWdWVSb3V0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcyIsIi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbGlzdCBmb3JtYXQgcHJvZHVjZWQgYnkgY3NzLWxvYWRlciBpbnRvIHNvbWV0aGluZ1xuICogZWFzaWVyIHRvIG1hbmlwdWxhdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzIiwiLyohXG4gKiBWdWUuanMgdjIuNi4xNFxuICogKGMpIDIwMTQtMjAyMSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiAoXG4gICAgaXNEZWYodmFsKSAmJlxuICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAnc2VydmVyUHJlZmV0Y2gnXG5dO1xuXG4vKiAgKi9cblxuXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbnZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IG5ldyBSZWdFeHAoKFwiW15cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIi4kX1xcXFxkXVwiKSk7XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbnZhciBpc1BoYW50b21KUyA9IFVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xudmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtO1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAvLyBvcmRlclxuICAgIHN1YnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbi8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICAvLyAjNzk3NVxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgIC8vIGEgY2hpbGQuXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgIHByb3RvQXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gIGlmICgoIWdldHRlciB8fCBzZXR0ZXIpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YWwgPSBvYmpba2V5XTtcbiAgfVxuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICBpZiAoZ2V0dGVyICYmICFzZXR0ZXIpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICB2YXIgcmVzID0gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsO1xuICByZXR1cm4gcmVzXG4gICAgPyBkZWR1cGVIb29rcyhyZXMpXG4gICAgOiByZXNcbn1cblxuZnVuY3Rpb24gZGVkdXBlSG9va3MgKGhvb2tzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICByZXMucHVzaChob29rc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIW5ldyBSZWdFeHAoKFwiXlthLXpBLVpdW1xcXFwtXFxcXC4wLTlfXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKiRcIikpLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICdpZDogJyArIG5hbWVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiQkMSA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlKVxuICApIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0sIHZtKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoYXZlRXhwZWN0ZWRUeXBlcyA9IGV4cGVjdGVkVHlwZXMuc29tZShmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfSk7XG4gIGlmICghdmFsaWQgJiYgaGF2ZUV4cGVjdGVkVHlwZXMpIHtcbiAgICB3YXJuKFxuICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbHxCaWdJbnQpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlLCB2bSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcCB0eXBlOiBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgaXMgbm90IGEgY29uc3RydWN0b3InLCB2bSk7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbnZhciBmdW5jdGlvblR5cGVDaGVja1JFID0gL15cXHMqZnVuY3Rpb24gKFxcdyspLztcblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaChmdW5jdGlvblR5cGVDaGVja1JFKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICBpZiAoXG4gICAgZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgIGlzRXhwbGljYWJsZSh0eXBlb2YgdmFsdWUpICYmXG4gICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSlcbiAgKSB7XG4gICAgbWVzc2FnZSArPSBcIiB3aXRoIHZhbHVlIFwiICsgKHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSkpO1xuICB9XG4gIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIiArIHJlY2VpdmVkVHlwZSArIFwiIFwiO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBcIndpdGggdmFsdWUgXCIgKyAoc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKSkgKyBcIi5cIjtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlICh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSlcbiAgfVxufVxuXG52YXIgRVhQTElDQUJMRV9UWVBFUyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gIHJldHVybiBFWFBMSUNBQkxFX1RZUEVTLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoKSB7XG4gIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgaWYgKHZtKSB7XG4gICAgICB2YXIgY3VyID0gdm07XG4gICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICBoYW5kbGVyLFxuICBjb250ZXh0LFxuICBhcmdzLFxuICB2bSxcbiAgaW5mb1xuKSB7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSAmJiAhcmVzLl9oYW5kbGVkKSB7XG4gICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXCIgKFByb21pc2UvYXN5bmMpXCIpOyB9KTtcbiAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAvLyBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxudmFyIHRpbWVyRnVuYztcblxuLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbi8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4vLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICB2YXIgY291bnRlciA9IDE7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcbiAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfSk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAvLyBUZWNobmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICB2YXIgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIHRpbWVyRnVuYygpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgIH07XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgd2FyblJlc2VydmVkUHJlZml4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIgKyBrZXkgKyBcIlxcXCIgYmVjYXVzZSBcIiArXG4gICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscy4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8XG4gICAgICAgICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuY2hhckF0KDApID09PSAnXycgJiYgIShrZXkgaW4gdGFyZ2V0LiRkYXRhKSk7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zLCB2bSkge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMkMSwgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZucywgbnVsbCwgYXJndW1lbnRzLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIilcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmJCQxID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyLCB2bSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlT25jZUhhbmRsZXIoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xuICB9XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgKGNbMF0pLnRleHQpO1xuICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgLy8gIzY1NzQgaW4gY2FzZSB0aGUgaW5qZWN0IG9iamVjdCBpcyBvYnNlcnZlZC4uLlxuICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJldHVybiB7fVxuICB9XG4gIHZhciBzbG90cyA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBub3JtYWxTbG90cyxcbiAgcHJldlNsb3RzXG4pIHtcbiAgdmFyIHJlcztcbiAgdmFyIGhhc05vcm1hbFNsb3RzID0gT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA+IDA7XG4gIHZhciBpc1N0YWJsZSA9IHNsb3RzID8gISFzbG90cy4kc3RhYmxlIDogIWhhc05vcm1hbFNsb3RzO1xuICB2YXIga2V5ID0gc2xvdHMgJiYgc2xvdHMuJGtleTtcbiAgaWYgKCFzbG90cykge1xuICAgIHJlcyA9IHt9O1xuICB9IGVsc2UgaWYgKHNsb3RzLl9ub3JtYWxpemVkKSB7XG4gICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgcmV0dXJuIHNsb3RzLl9ub3JtYWxpemVkXG4gIH0gZWxzZSBpZiAoXG4gICAgaXNTdGFibGUgJiZcbiAgICBwcmV2U2xvdHMgJiZcbiAgICBwcmV2U2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXG4gICAga2V5ID09PSBwcmV2U2xvdHMuJGtleSAmJlxuICAgICFoYXNOb3JtYWxTbG90cyAmJlxuICAgICFwcmV2U2xvdHMuJGhhc05vcm1hbFxuICApIHtcbiAgICAvLyBmYXN0IHBhdGggMjogc3RhYmxlIHNjb3BlZCBzbG90cyB3LyBubyBub3JtYWwgc2xvdHMgdG8gcHJveHksXG4gICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgcmV0dXJuIHByZXZTbG90c1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XG4gICAgICBpZiAoc2xvdHNba2V5JDFdICYmIGtleSQxWzBdICE9PSAnJCcpIHtcbiAgICAgICAgcmVzW2tleSQxXSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSQxLCBzbG90c1trZXkkMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gIGZvciAodmFyIGtleSQyIGluIG5vcm1hbFNsb3RzKSB7XG4gICAgaWYgKCEoa2V5JDIgaW4gcmVzKSkge1xuICAgICAgcmVzW2tleSQyXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5JDIpO1xuICAgIH1cbiAgfVxuICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gIC8vIGFuZCB3aGVuIHRoYXQgaXMgcGFzc2VkIGRvd24gdGhpcyB3b3VsZCBjYXVzZSBhbiBlcnJvclxuICBpZiAoc2xvdHMgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShzbG90cykpIHtcbiAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xuICB9XG4gIGRlZihyZXMsICckc3RhYmxlJywgaXNTdGFibGUpO1xuICBkZWYocmVzLCAnJGtleScsIGtleSk7XG4gIGRlZihyZXMsICckaGFzTm9ybWFsJywgaGFzTm9ybWFsU2xvdHMpO1xuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgZm4pIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgIHJlcyA9IHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShyZXMpXG4gICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxuICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgIHZhciB2bm9kZSA9IHJlcyAmJiByZXNbMF07XG4gICAgcmV0dXJuIHJlcyAmJiAoXG4gICAgICAhdm5vZGUgfHxcbiAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHZub2RlLmlzQ29tbWVudCAmJiAhaXNBc3luY1BsYWNlaG9sZGVyKHZub2RlKSkgLy8gIzk2NTgsICMxMDM5MVxuICAgICkgPyB1bmRlZmluZWRcbiAgICAgIDogcmVzXG4gIH07XG4gIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcbiAgLy8gb24gdGhpcy4kc2xvdHMgYmVjYXVzZSB0aGUgdXNhZ2UgaXMgc2VtYW50aWNhbGx5IGEgbm9ybWFsIHNsb3QuXG4gIGlmIChmbi5wcm94eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICBnZXQ6IG5vcm1hbGl6ZWQsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRcbn1cblxuZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNsb3RzW2tleV07IH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFja1JlbmRlcixcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikge1xuICAgIC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPVxuICAgICAgc2NvcGVkU2xvdEZuKHByb3BzKSB8fFxuICAgICAgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gIH0gZWxzZSB7XG4gICAgbm9kZXMgPVxuICAgICAgdGhpcy4kc2xvdHNbbmFtZV0gfHxcbiAgICAgICh0eXBlb2YgZmFsbGJhY2tSZW5kZXIgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFja1JlbmRlcigpIDogZmFsbGJhY2tSZW5kZXIpO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbiAgcmV0dXJuIGV2ZW50S2V5Q29kZSA9PT0gdW5kZWZpbmVkXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzLFxuICAvLyB0aGUgZm9sbG93aW5nIGFyZSBhZGRlZCBpbiAyLjZcbiAgaGFzRHluYW1pY0tleXMsXG4gIGNvbnRlbnRIYXNoS2V5XG4pIHtcbiAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNsb3QgPSBmbnNbaV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2xvdCkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCByZXMsIGhhc0R5bmFtaWNLZXlzKTtcbiAgICB9IGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgIC8vIG1hcmtlciBmb3IgcmV2ZXJzZSBwcm94eWluZyB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgICAgaWYgKHNsb3QucHJveHkpIHtcbiAgICAgICAgc2xvdC5mbi5wcm94eSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXNbc2xvdC5rZXldID0gc2xvdC5mbjtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnRIYXNoS2V5KSB7XG4gICAgKHJlcykuJGtleSA9IGNvbnRlbnRIYXNoS2V5O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmREeW5hbWljS2V5cyAoYmFzZU9iaiwgdmFsdWVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGtleSA9IHZhbHVlc1tpXTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XG4gICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBrZXkgIT09ICcnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgLy8gbnVsbCBpcyBhIHNwZWNpYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXG4gICAgICB3YXJuKFxuICAgICAgICAoXCJJbnZhbGlkIHZhbHVlIGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCAoZXhwZWN0ZWQgc3RyaW5nIG9yIG51bGwpOiBcIiArIGtleSksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlT2JqXG59XG5cbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3Rcbi8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIGNvbnRleHRWbTtcbiAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gIH1cbiAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMkMS4kc2xvdHMpIHtcbiAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBkYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB0aGlzJDEuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcyQxLiRzbG90c1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCAoe1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSlcbiAgICB9XG4gIH0pKTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cblxuICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHRWbSxcbiAgICBDdG9yXG4gICk7XG5cbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHZhciB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcbiAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuICB9XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0ICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgaWYgKFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3Rvcik7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHZub2RlLFxuICAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50XG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgcGFyZW50OiBwYXJlbnRcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBleGlzdGluZyA9IGhvb2tzW2tleV07XG4gICAgdmFyIHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayQxKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChmMSwgZjIpIHtcbiAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgIGYxKGEsIGIpO1xuICAgIGYyKGEsIGIpO1xuICB9O1xuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgaWYgKFxuICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIG9uW2V2ZW50XSA9IFtjYWxsYmFja10uY29uY2F0KGV4aXN0aW5nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5uYXRpdmVPbikgJiYgZGF0YS50YWcgIT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiVGhlIC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaXMgb25seSB2YWxpZCBvbiBjb21wb25lbnRzIGJ1dCBpdCB3YXMgdXNlZCBvbiA8XCIgKyB0YWcgKyBcIj4uXCIpLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1c2UgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgIDsob3duZXIpLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUob3duZXJzLCBvd25lcik7IH0pO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dCk7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgdmFyIG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpIHx8XG4gICAgKCFuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSlcbiAgKTtcblxuICAvLyBBbnkgc3RhdGljIHNsb3QgY2hpbGRyZW4gZnJvbSB0aGUgcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHBhcmVudCdzXG4gIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAvLyB1cGRhdGUgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcy5cbiAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIGhhc0R5bmFtaWNTY29wZWRTbG90XG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIHZhciBpbmZvID0gaG9vayArIFwiIGhvb2tcIjtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGhhbmRsZXJzW2ldLCB2bSwgbnVsbCwgdm0sIGluZm8pO1xuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbn1cblxuLyogICovXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gQXN5bmMgZWRnZSBjYXNlICM2NTY2IHJlcXVpcmVzIHNhdmluZyB0aGUgdGltZXN0YW1wIHdoZW4gZXZlbnQgbGlzdGVuZXJzIGFyZVxuLy8gYXR0YWNoZWQuIEhvd2V2ZXIsIGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgaGFzIGEgcGVyZiBvdmVyaGVhZCBlc3BlY2lhbGx5XG4vLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxuLy8gZXZlcnkgdGltZSB0aGUgc2NoZWR1bGVyIGZsdXNoZXMgYW5kIHVzZSB0aGF0IGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzXG4vLyBhdHRhY2hlZCBkdXJpbmcgdGhhdCBmbHVzaC5cbnZhciBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xuXG4vLyBBc3luYyBlZGdlIGNhc2UgZml4IHJlcXVpcmVzIHN0b3JpbmcgYW4gZXZlbnQgbGlzdGVuZXIncyBhdHRhY2ggdGltZXN0YW1wLlxudmFyIGdldE5vdyA9IERhdGUubm93O1xuXG4vLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcbi8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxuLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuLy8gQWxsIElFIHZlcnNpb25zIHVzZSBsb3ctcmVzIGV2ZW50IHRpbWVzdGFtcHMsIGFuZCBoYXZlIHByb2JsZW1hdGljIGNsb2NrXG4vLyBpbXBsZW1lbnRhdGlvbnMgKCM5NjMyKVxuaWYgKGluQnJvd3NlciAmJiAhaXNJRSkge1xuICB2YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIGlmIChcbiAgICBwZXJmb3JtYW5jZSAmJlxuICAgIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgJiZcbiAgICBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcFxuICApIHtcbiAgICAvLyBpZiB0aGUgZXZlbnQgdGltZXN0YW1wLCBhbHRob3VnaCBldmFsdWF0ZWQgQUZURVIgdGhlIERhdGUubm93KCksIGlzXG4gICAgLy8gc21hbGxlciB0aGFuIGl0LCBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgaGktcmVzIHZlcnNpb24gZm9yIGV2ZW50IGxpc3RlbmVyIHRpbWVzdGFtcHMgYXNcbiAgICAvLyB3ZWxsLlxuICAgIGdldE5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpOyB9O1xuICB9XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSBnZXROb3coKTtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZiAod2F0Y2hlci5iZWZvcmUpIHtcbiAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XG4gICAgfVxuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xuICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gbm9vcDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdmFyIGluZm8gPSBcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCI7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKHRoaXMuY2IsIHRoaXMudm0sIFt2YWx1ZSwgb2xkVmFsdWVdLCB0aGlzLnZtLCBpbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5tZXRob2RzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5tZXRob2RzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBtZXRob2QuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcylcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyB0eXBlIFxcXCJcIiArICh0eXBlb2YgbWV0aG9kc1trZXldKSArIFwiXFxcIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCI7XG4gICAgICBwdXNoVGFyZ2V0KCk7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYiwgdm0sIFt3YXRjaGVyLnZhbHVlXSwgdm0sIGluZm8pO1xuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgZW50cnkgPSBjYWNoZVtrZXldO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgdmFyIG5hbWUgPSBlbnRyeS5uYW1lO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBlbnRyeSA9IGNhY2hlW2tleV07XG4gIGlmIChlbnRyeSAmJiAoIWN1cnJlbnQgfHwgZW50cnkudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBlbnRyeS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgY2FjaGVWTm9kZTogZnVuY3Rpb24gY2FjaGVWTm9kZSgpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYua2V5cztcbiAgICAgIHZhciB2bm9kZVRvQ2FjaGUgPSByZWYudm5vZGVUb0NhY2hlO1xuICAgICAgdmFyIGtleVRvQ2FjaGUgPSByZWYua2V5VG9DYWNoZTtcbiAgICAgIGlmICh2bm9kZVRvQ2FjaGUpIHtcbiAgICAgICAgdmFyIHRhZyA9IHZub2RlVG9DYWNoZS50YWc7XG4gICAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlVG9DYWNoZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZVRvQ2FjaGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgY2FjaGVba2V5VG9DYWNoZV0gPSB7XG4gICAgICAgICAgbmFtZTogZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKSxcbiAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZTogY29tcG9uZW50SW5zdGFuY2UsXG4gICAgICAgIH07XG4gICAgICAgIGtleXMucHVzaChrZXlUb0NhY2hlKTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudm5vZGVUb0NhY2hlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlVk5vZGUoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVsYXkgc2V0dGluZyB0aGUgY2FjaGUgdW50aWwgdXBkYXRlXG4gICAgICAgIHRoaXMudm5vZGVUb0NhY2hlID0gdm5vZGU7XG4gICAgICAgIHRoaXMua2V5VG9DYWNoZSA9IGtleTtcbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNi4xNCc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbnZhciBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgPyAnZmFsc2UnXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogJ3RydWUnXG59O1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWdub2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cbnZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICB0YWdOYW1lOiB0YWdOYW1lLFxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiZcbiAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMoW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyLCB2bm9kZS5kYXRhLnByZSk7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUsIGlzSW5QcmUpIHtcbiAgaWYgKGlzSW5QcmUgfHwgZWwudGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiB2YWx1ZSAhPT0gJycgJiYgIWVsLl9faWVwaFxuICAgICkge1xuICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgfTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyAoYXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3MpKVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIHZhciBhdHRycyA9IGR5bmFtaWNcbiAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICA6IChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpO1xuICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbmZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0sIHJhbmdlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBpc0R5bmFtaWNBcmcsXG4gIG1vZGlmaWVycyxcbiAgcmFuZ2Vcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3TmFtZTogcmF3TmFtZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgYXJnOiBhcmcsXG4gICAgaXNEeW5hbWljQXJnOiBpc0R5bmFtaWNBcmcsXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbiAgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgcmV0dXJuIGR5bmFtaWNcbiAgICA/IChcIl9wKFwiICsgbmFtZSArIFwiLFxcXCJcIiArIHN5bWJvbCArIFwiXFxcIilcIilcbiAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm4sXG4gIHJhbmdlLFxuICBkeW5hbWljXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJyxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOihcIiArIG5hbWUgKyBcIilcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCchJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyYnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuXG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICB2YXIgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpO1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmF3QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwWyd2LWJpbmQ6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbbmFtZV1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgZWwsXG4gIG5hbWVcbikge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgaXRlbSxcbiAgcmFuZ2Vcbikge1xuICBpZiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJyxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJykpICsgXCIpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgIHZhciB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh2YWx1ZSQxICYmICF0eXBlQmluZGluZykge1xuICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW2JpbmRpbmddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuLy8gc2FmZSB0byBleGNsdWRlLlxudmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICB2YXIgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XG4gICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cbiAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXAgfHxcbiAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgLy8gIzk2ODEgUXRXZWJFbmdpbmUgZXZlbnQudGltZVN0YW1wIGlzIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbnZhciBzdmdDb250YWluZXI7XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNzYXJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICBjdXIgIT09IG9sZFByb3BzW2tleV1cbiAgICApIHtcbiAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxudmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBpc05vdFRleHROb2RlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfTtcblxudmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XG4gICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICB0aGlzJDEuX19wYXRjaF9fKFxuICAgICAgICB0aGlzJDEuX3Zub2RlLFxuICAgICAgICB0aGlzJDEua2VwdCxcbiAgICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICk7XG4gICAgICB0aGlzJDEuX3Zub2RlID0gdGhpcyQxLmtlcHQ7XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMkMSwgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxyP1xcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cblxuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHJhd1Rva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxuICAgIHRva2VuczogcmF3VG9rZW5zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ2NsYXNzJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LicsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxudmFyIGhlID0ge1xuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG52YXIgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rP1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG52YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qXCI7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxudmFyIGNvbW1lbnQgPSAvXjwhXFwtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnLFxuICAnJiMzOTsnOiBcIidcIlxufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5fCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YXJ0VGFnTWF0Y2gudGFnTmFtZSwgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgYWR2YW5jZSh0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0LCBpbmRleCAtIHRleHQubGVuZ3RoLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIiksIHsgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGggfSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChkeW5hbWljQXJnQXR0cmlidXRlKSB8fCBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIGF0dHIuZW5kID0gaW5kZXg7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxuICAgICAgfTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxccyovKS5sZW5ndGg7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICB7IHN0YXJ0OiBzdGFja1tpXS5zdGFydCwgZW5kOiBzdGFja1tpXS5lbmQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8Xjp8XiMvO1xudmFyIGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xudmFyIGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZztcblxudmFyIHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuXG52YXIgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xudmFyIHdoaXRlc3BhY2VSRSQxID0gL1sgXFxmXFx0XFxyXFxuXSsvZztcblxudmFyIGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbnZhciBlbXB0eVNsb3RTY29wZVRva2VuID0gXCJfZW1wdHlfXCI7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG52YXIgbWF5YmVDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnOiB0YWcsXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICByYXdBdHRyc01hcDoge30sXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICBtYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISEoXG4gICAgZWwuY29tcG9uZW50IHx8XG4gICAgZWwuYXR0cnNNYXBbJzppcyddIHx8XG4gICAgZWwuYXR0cnNNYXBbJ3YtYmluZDppcyddIHx8XG4gICAgIShlbC5hdHRyc01hcC5pcyA/IGlzUmVzZXJ2ZWRUYWcoZWwuYXR0cnNNYXAuaXMpIDogaXNSZXNlcnZlZFRhZyhlbC50YWcpKVxuICApOyB9O1xuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2csIHJhbmdlKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnLCByYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG4gICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICBlbGVtZW50ID0gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgIGlmICghc3RhY2subGVuZ3RoICYmIGVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCIsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAvLyBrZWVwIGl0IGluIHRoZSBjaGlsZHJlbiBsaXN0IHNvIHRoYXQgdi1lbHNlKC1pZikgY29uZGl0aW9ucyBjYW5cbiAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJ1xuICAgICAgICAgIDsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmFsIGNoaWxkcmVuIGNsZWFudXBcbiAgICAvLyBmaWx0ZXIgb3V0IHNjb3BlZCBzbG90c1xuICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIShjKS5zbG90U2NvcGU7IH0pO1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcblxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgIGlmICghaW5QcmUpIHtcbiAgICAgIHZhciBsYXN0Tm9kZTtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnXG4gICAgICApIHtcbiAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJyxcbiAgICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBvdXRwdXRTb3VyY2VSYW5nZTogb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5LCBzdGFydCQxLCBlbmQpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgZWxlbWVudC5yYXdBdHRyc01hcCA9IGVsZW1lbnQuYXR0cnNMaXN0LnJlZHVjZShmdW5jdGlvbiAoY3VtdWxhdGVkLCBhdHRyKSB7XG4gICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICBcInNwYWNlcywgcXVvdGVzLCA8LCA+LCAvIG9yID0uXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKHRhZywgc3RhcnQsIGVuZCQxKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQkMTtcbiAgICAgIH1cbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmICghaW5QcmUgJiYgd2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlUkUkMSwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIGFkZGluZyBhbnl0aGluZyBhcyBhIHNpYmxpbmcgdG8gdGhlIHJvb3Qgbm9kZSBpcyBmb3JiaWRkZW5cbiAgICAgIC8vIGNvbW1lbnRzIHNob3VsZCBzdGlsbCBiZSBhbGxvd2VkLCBidXQgaWdub3JlZFxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbikge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGxpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGxpc3RbaV0uc3RhcnQ7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGxpc3RbaV0uZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRWxlbWVudCAoXG4gIGVsZW1lbnQsXG4gIG9wdGlvbnNcbikge1xuICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICBlbGVtZW50LnBsYWluID0gKFxuICAgICFlbGVtZW50LmtleSAmJlxuICAgICFlbGVtZW50LnNjb3BlZFNsb3RzICYmXG4gICAgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aFxuICApO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90Q29udGVudChlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XG4gIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gIH1cbiAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICByZXR1cm4gZWxlbWVudFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZWwuZm9yKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIGlmIChpdGVyYXRvciAmJiBpdGVyYXRvciA9PT0gZXhwICYmIHBhcmVudCAmJiBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcIkRvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgXCIgK1xuICAgICAgICAgICAgXCJ0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLlwiLFxuICAgICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKSxcbiAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cCksXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbZWwuZWxzZWlmID8gJ3YtZWxzZS1pZicgOiAndi1lbHNlJ11cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgY2hpbGRyZW5baV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbi8vIGhhbmRsZSBjb250ZW50IGJlaW5nIHBhc3NlZCB0byBhIGNvbXBvbmVudCBhcyBzbG90LFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XG4gIHZhciBzbG90U2NvcGU7XG4gIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90U2NvcGUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICBcInJlcGxhY2VkIGJ5IFxcXCJzbG90LXNjb3BlXFxcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXFxcInNsb3Qtc2NvcGVcXFwiIGF0dHJpYnV0ZSBcIiArXG4gICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xuICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXG4gICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gIH1cblxuICAvLyBzbG90PVwieHh4XCJcbiAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSAhIShlbC5hdHRyc01hcFsnOnNsb3QnXSB8fCBlbC5hdHRyc01hcFsndi1iaW5kOnNsb3QnXSk7XG4gICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgaWYgKGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICB9XG4gIH1cblxuICAvLyAyLjYgdi1zbG90IHN5bnRheFxuICB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cbiAgICAgIHZhciBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5wYXJlbnQgJiYgIW1heWJlQ29tcG9uZW50KGVsLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCI8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIFwiICtcbiAgICAgICAgICAgICAgXCJ0aGUgcmVjZWl2aW5nIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZiA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMgPSByZWYuZHluYW1pYztcbiAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHYtc2xvdCBvbiBjb21wb25lbnQsIGRlbm90ZXMgZGVmYXVsdCBzbG90XG4gICAgICB2YXIgc2xvdEJpbmRpbmckMSA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nJDEpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIW1heWJlQ29tcG9uZW50KGVsKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgdmFyIHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xuICAgICAgICB2YXIgcmVmJDEgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyQxKTtcbiAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgIHZhciBkeW5hbWljJDEgPSByZWYkMS5keW5hbWljO1xuICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHNsb3RzW25hbWUkMV0gPSBjcmVhdGVBU1RFbGVtZW50KCd0ZW1wbGF0ZScsIFtdLCBlbCk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWMkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGMucGFyZW50ID0gc2xvdENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90U2NvcGUgPSBzbG90QmluZGluZyQxLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNsb3ROYW1lIChiaW5kaW5nKSB7XG4gIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gIGlmICghbmFtZSkge1xuICAgIGlmIChiaW5kaW5nLm5hbWVbMF0gIT09ICcjJykge1xuICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJ2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5cIixcbiAgICAgICAgYmluZGluZ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgLy8gZHluYW1pYyBbbmFtZV1cbiAgICA/IHsgbmFtZTogbmFtZS5zbGljZSgxLCAtMSksIGR5bmFtaWM6IHRydWUgfVxuICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgOiB7IG5hbWU6IChcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiksIGR5bmFtaWM6IGZhbHNlIH1cbn1cblxuLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiLFxuICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIHZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgKFwiVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXFxcInYtYmluZDpcIiArIG5hbWUgKyBcIlxcXCJcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3AgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpO1xuICAgICAgICAgICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgKFwiXFxcInVwZGF0ZTpcXFwiKyhcIiArIG5hbWUgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldLFxuICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJvcCkgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgdHlwZUJpbmRpbmc7XG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgfVxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgIH1cblxuICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcbiAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgIGJyYW5jaDAuaWYgPSBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J2NoZWNrYm94J1wiICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxuICAgICAgICBibG9jazogYnJhbmNoMFxuICAgICAgfSk7XG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgIHZhciBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgIH0pO1xuICAgICAgLy8gMy4gb3RoZXJcbiAgICAgIHZhciBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycyxzdGFydCxlbmQscmF3QXR0cnNNYXAnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xudmFyIGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJ1teJ10qPyddfFxcW1wiW15cIl0qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKiQvO1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xudmFyIGtleU5hbWVzID0ge1xuICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cbiAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZVxuKSB7XG4gIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gIHZhciBzdGF0aWNIYW5kbGVycyA9IFwiXCI7XG4gIHZhciBkeW5hbWljSGFuZGxlcnMgPSBcIlwiO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHZhciBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcbiAgICBpZiAoZXZlbnRzW25hbWVdICYmIGV2ZW50c1tuYW1lXS5keW5hbWljKSB7XG4gICAgICBkeW5hbWljSGFuZGxlcnMgKz0gbmFtZSArIFwiLFwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljSGFuZGxlcnMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgc3RhdGljSGFuZGxlcnMgPSBcIntcIiArIChzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCJfZChcIiArIHN0YXRpY0hhbmRsZXJzICsgXCIsW1wiICsgKGR5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJdKVwiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChpc0Z1bmN0aW9uSW52b2NhdGlvbiA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSkgOiBoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIi5hcHBseShudWxsLCBhcmd1bWVudHMpXCIpXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKS5hcHBseShudWxsLCBhcmd1bWVudHMpXCIpXG4gICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSlcbiAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgIC8vIGtleSBldmVudHMgdGhhdCBkbyBub3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5Li4uXG4gICAgXCJpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJlwiICtcbiAgICAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIlxuICApXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleUNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXksXCIgK1xuICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICBcIilcIlxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkaXIubW9kaWZpZXJzKSB7XG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uOiBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cblxuXG5cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICB0aGlzLnByZSA9IGZhbHNlO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgLy8gZml4ICMxMTQ4MywgUm9vdCBsZXZlbCA8c2NyaXB0PiB0YWdzIHNob3VsZCBub3QgYmUgcmVuZGVyZWQuXG4gIHZhciBjb2RlID0gYXN0ID8gKGFzdC50YWcgPT09ICdzY3JpcHQnID8gJ251bGwnIDogZ2VuRWxlbWVudChhc3QsIHN0YXRlKSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5wYXJlbnQpIHtcbiAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcbiAgfVxuXG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQgJiYgIXN0YXRlLnByZSkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGE7XG4gICAgICBpZiAoIWVsLnBsYWluIHx8IChlbC5wcmUgJiYgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpKSkge1xuICAgICAgICBkYXRhID0gZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gIC8vIG5vZGUuICBBbGwgcHJlIG5vZGVzIGFyZSBzdGF0aWMgcm9vdHMsIHNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGxvY2F0aW9uIHRvXG4gIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xuICBpZiAoZWwucHJlKSB7XG4gICAgc3RhdGUucHJlID0gZWwucHJlO1xuICB9XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW9uY2UnXVxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwiLFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwiLFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbCwgZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gIC8vIHYtYmluZCB3aXRoIGR5bmFtaWMgYXJndW1lbnRzIG11c3QgYmUgYXBwbGllZCB1c2luZyB0aGUgc2FtZSB2LWJpbmQgb2JqZWN0XG4gIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgIGRhdGEgPSBcIl9iKFwiICsgZGF0YSArIFwiLFxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiICsgKGdlblByb3BzKGVsLmR5bmFtaWNBdHRycykpICsgXCIpXCI7XG4gIH1cbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XCIgKyAoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiAoXCJcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikpKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICAnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyxcbiAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICApO1xuICB9XG4gIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgZWwsXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxuICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSBlbC5mb3IgfHwgT2JqZWN0LmtleXMoc2xvdHMpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzbG90ID0gc2xvdHNba2V5XTtcbiAgICByZXR1cm4gKFxuICAgICAgc2xvdC5zbG90VGFyZ2V0RHluYW1pYyB8fFxuICAgICAgc2xvdC5pZiB8fFxuICAgICAgc2xvdC5mb3IgfHxcbiAgICAgIGNvbnRhaW5zU2xvdENoaWxkKHNsb3QpIC8vIGlzIHBhc3NpbmcgZG93biBzbG90IGZyb20gcGFyZW50IHdoaWNoIG1heSBiZSBkeW5hbWljXG4gICAgKVxuICB9KTtcblxuICAvLyAjOTUzNDogaWYgYSBjb21wb25lbnQgd2l0aCBzY29wZWQgc2xvdHMgaXMgaW5zaWRlIGEgY29uZGl0aW9uYWwgYnJhbmNoLFxuICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxuICAvLyBjb21waWxlZCBzbG90IGNvbnRlbnQuIFRvIGF2b2lkIHRoYXQsIHdlIGdlbmVyYXRlIGEgdW5pcXVlIGtleSBiYXNlZCBvblxuICAvLyB0aGUgZ2VuZXJhdGVkIGNvZGUgb2YgYWxsIHRoZSBzbG90IGNvbnRlbnRzLlxuICB2YXIgbmVlZHNLZXkgPSAhIWVsLmlmO1xuXG4gIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3Qgb3Igdi1mb3IgKHRoZSByZWFjdGl2aXR5IG1heSBiZVxuICAvLyBkaXNjb25uZWN0ZWQgZHVlIHRvIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgdmFyaWFibGUpXG4gIC8vICM5NDM4LCAjOTUwNlxuICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBwcm9wZXJseSBhbmFseXppbmcgaW4tc2NvcGUgYmluZGluZ3NcbiAgLy8gYW5kIHNraXAgZm9yY2UgdXBkYXRpbmcgb25lcyB0aGF0IGRvIG5vdCBhY3R1YWxseSB1c2Ugc2NvcGUgdmFyaWFibGVzLlxuICBpZiAoIW5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikgfHxcbiAgICAgICAgcGFyZW50LmZvclxuICAgICAgKSB7XG4gICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5pZikge1xuICAgICAgICBuZWVkc0tleSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciBnZW5lcmF0ZWRTbG90cyA9IE9iamVjdC5rZXlzKHNsb3RzKVxuICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSk7IH0pXG4gICAgLmpvaW4oJywnKTtcblxuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgZ2VuZXJhdGVkU2xvdHMgKyBcIl1cIiArIChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKSArICghbmVlZHNGb3JjZVVwZGF0ZSAmJiBuZWVkc0tleSA/IChcIixudWxsLGZhbHNlLFwiICsgKGhhc2goZ2VuZXJhdGVkU2xvdHMpKSkgOiBcIlwiKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICB2YXIgaGFzaCA9IDUzODE7XG4gIHZhciBpID0gc3RyLmxlbmd0aDtcbiAgd2hpbGUoaSkge1xuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gIH1cbiAgcmV0dXJuIGhhc2ggPj4+IDBcbn1cblxuZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBpc0xlZ2FjeVN5bnRheCA9IGVsLmF0dHJzTWFwWydzbG90LXNjb3BlJ107XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQgJiYgIWlzTGVnYWN5U3ludGF4KSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCwgXCJudWxsXCIpXG4gIH1cbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gIH1cbiAgdmFyIHNsb3RTY29wZSA9IGVsLnNsb3RTY29wZSA9PT0gZW1wdHlTbG90U2NvcGVUb2tlblxuICAgID8gXCJcIlxuICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyBzbG90U2NvcGUgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICA/IChcIihcIiArIChlbC5pZikgKyBcIik/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcbiAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICB2YXIgcmV2ZXJzZVByb3h5ID0gc2xvdFNjb3BlID8gXCJcIiA6IFwiLHByb3h5OnRydWVcIjtcbiAgcmV0dXJuIChcIntrZXk6XCIgKyAoZWwuc2xvdFRhcmdldCB8fCBcIlxcXCJkZWZhdWx0XFxcIlwiKSArIFwiLGZuOlwiICsgZm4gKyByZXZlcnNlUHJveHkgKyBcIn1cIilcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgICA/IHN0YXRlLm1heWJlQ29tcG9uZW50KGVsJDEpID8gXCIsMVwiIDogXCIsMFwiXG4gICAgICAgIDogXCJcIjtcbiAgICAgIHJldHVybiAoXCJcIiArICgoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSkpICsgbm9ybWFsaXphdGlvblR5cGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSQxID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUkMSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlJDEpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsZnVuY3Rpb24oKXtyZXR1cm4gXCIgKyBjaGlsZHJlbiArIFwifVwiKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgLy8gc2xvdCBwcm9wcyBhcmUgY2FtZWxpemVkXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICBkeW5hbWljOiBhdHRyLmR5bmFtaWNcbiAgICAgIH0pOyB9KSlcbiAgICA6IG51bGw7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciBzdGF0aWNQcm9wcyA9IFwiXCI7XG4gIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XG4gICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgZHluYW1pY1Byb3BzICs9IChwcm9wLm5hbWUpICsgXCIsXCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgdmFsdWUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgc3RhdGljUHJvcHMgPSBcIntcIiArIChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gKFwiX2QoXCIgKyBzdGF0aWNQcm9wcyArIFwiLFtcIiArIChkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgfVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCB3YXJuKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndi1zbG90JyB8fCBuYW1lWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdmFyIHN0cmlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RyaXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RyaXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICB3YXJuKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIHdhcm4sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybigoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSksIHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihleHAsICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHdhcm4oXG4gICAgICBcImludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciByYW5nZSA9IDI7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgc291cmNlLFxuICBzdGFydCxcbiAgZW5kXG4pIHtcbiAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoJDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbignXFxuJylcbn1cblxuZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmIChuID4gMCkge1xuICAgIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICBuID4+Pj0gMTtcbiAgICAgIGlmIChuIDw9IDApIHsgYnJlYWsgfVxuICAgICAgc3RyICs9IHN0cjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyAoZS5tc2cpICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aXAoZS5tc2csIHZtKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcblxuICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHsgbXNnOiBtc2cgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUvZGlzdC92dWUuZXNtLmpzIiwicmVxdWlyZSgnLi4vLi4vc3JjL3N0eWxlcy9tYWluLnNjc3MnKTtcclxuXHJcbi8vIExvYWQgbGlicmFyeVxyXG5INVAuRmVlZGJhY2sgPSByZXF1aXJlKCcuLi9zY3JpcHRzL2FwcCcpLmRlZmF1bHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VudHJpZXMvZGlzdC5qcyIsImltcG9ydCBzdGlwdGFncyBmcm9tICdzdHJpcHRhZ3MnO1xyXG5cclxuY29uc3QgSW50ZXJhY3Rpb25UeXBlID0ge1xyXG4gIEZJTExfSU46ICdmaWxsLWluJyxcclxuICBMSUtFUlQ6ICdsaWtlcnQnXHJcbn07XHJcblxyXG5jb25zdCBUeXBlID0ge1xyXG4gIElOVEVSQUNUSU9OOiAnaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL2FjdGl2aXRpZXMvY21pLmludGVyYWN0aW9uJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWEFQSUJ1aWxkZXIge1xyXG4gIGNvbnN0cnVjdG9yKHF1ZXN0aW9uKSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBhbnN3ZXJlZCB4QVBJIGV2ZW50IHdpdGggd2l0aCB0aGUgc2NvcmVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7WEFQSUV2ZW50fSBldmVudFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjcmlwdGlvblxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY29yZVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjYWxlXHJcbiAgICogQHJldHVybiB7WEFQSUV2ZW50fVxyXG4gICAqL1xyXG4gIGNyZWF0ZUxpa2VydEV2ZW50KGV2ZW50LCBkZXNjcmlwdGlvbiwgc2NvcmUsIHNjYWxlKSB7XHJcbiAgICAvLyBwcmVwYXJlIHF1ZXN0aW9uXHJcbiAgICBjb25zdCBkZWZpbml0aW9uID0gZXZlbnQuZ2V0VmVyaWZpZWRTdGF0ZW1lbnRWYWx1ZShbJ29iamVjdCcsICdkZWZpbml0aW9uJ10pO1xyXG4gICAgZGVmaW5pdGlvbi5kZXNjcmlwdGlvbiA9IHRoaXMud3JhcEFzVHJhbnNsYXRpb24oZGVzY3JpcHRpb24pO1xyXG4gICAgZGVmaW5pdGlvbi50eXBlID0gVHlwZS5JTlRFUkFDVElPTjtcclxuICAgIGRlZmluaXRpb24uaW50ZXJhY3Rpb25UeXBlID0gSW50ZXJhY3Rpb25UeXBlLkxJS0VSVDtcclxuICAgIGRlZmluaXRpb24uY29ycmVjdFJlc3BvbnNlc1BhdHRlcm4gPSBbc2NvcmVdO1xyXG4gICAgZGVmaW5pdGlvbi5zY2FsZSA9IHNjYWxlO1xyXG5cclxuICAgIC8vIHByZXBhcmUgYW5zd2VyXHJcblxyXG4gICAgcmV0dXJuIGV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBhbnN3ZXJlZCB4QVBJIGV2ZW50IHdpdGggd2l0aCB0aGUgcmVzcG9uc2UgdGV4dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtYQVBJRXZlbnR9IGV2ZW50XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRlc2NyaXB0aW9uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVGV4dFxyXG4gICAqIEByZXR1cm4ge1hBUElFdmVudH1cclxuICAgKi9cclxuICBjcmVhdGVUZXh0RXZlbnQoZXZlbnQsIGRlc2NyaXB0aW9uLCByZXNwb25zZVRleHQpIHtcclxuICAgIC8vIHByZXBhcmUgcXVlc3Rpb25cclxuICAgIGNvbnN0IGRlZmluaXRpb24gPSBldmVudC5nZXRWZXJpZmllZFN0YXRlbWVudFZhbHVlKFsnb2JqZWN0JywgJ2RlZmluaXRpb24nXSk7XHJcbiAgICBkZWZpbml0aW9uLmRlc2NyaXB0aW9uID0gdGhpcy53cmFwQXNUcmFuc2xhdGlvbihkZXNjcmlwdGlvbik7XHJcbiAgICBkZWZpbml0aW9uLnR5cGUgPSBUeXBlLklOVEVSQUNUSU9OO1xyXG4gICAgZGVmaW5pdGlvbi5pbnRlcmFjdGlvblR5cGUgPSBJbnRlcmFjdGlvblR5cGUuRklMTF9JTjtcclxuICAgIGRlZmluaXRpb24uY29ycmVjdFJlc3BvbnNlc1BhdHRlcm4gPSBbcmVzcG9uc2VUZXh0XTtcclxuXHJcbiAgICByZXR1cm4gZXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIGFkZFJlc3BvbnNlVG9YQVBJIChldmVudCkge1xyXG4gICAgY29uc3QgaXNDb3JyZWN0ID0gYW5zd2VyR3JvdXAuaXNDb3JyZWN0KCk7XHJcbiAgICBldmVudC5zZXRTY29yZWRSZXN1bHQoaXNDb3JyZWN0ID8gTUFYX1NDT1JFIDogMCwgTUFYX1NDT1JFLCBzZWxmLCB0cnVlLCBpc0NvcnJlY3QpO1xyXG4gICAgZXZlbnQuZGF0YS5zdGF0ZW1lbnQucmVzdWx0LnJlc3BvbnNlID0gKGlzQ29ycmVjdCA/IGdldENvcnJlY3RBbnN3ZXIoKSA6IGdldFdyb25nQW5zd2VyKCkpO1xyXG4gIH07Ki9cclxuXHJcbiAgLyoqXHJcbiAgICogV3JhcHMgYSBzdHJpbmcgYXMgdHJhbnNsYXRpb24gZm9yIGVuLVVTXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICogQHJldHVybiB7b2JqZWN0fVxyXG4gICAqL1xyXG4gIHdyYXBBc1RyYW5zbGF0aW9uKHN0cikge1xyXG4gICAgcmV0dXJuIHsgJ2VuLVVTJzogc3RpcHRhZ3Moc3RyKSB9O1xyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NvbXBvbmVudHMveGFwaS5qcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5mZWVkYmFjay1zY29yZS1pbnB1dCB7XFxuICBtYXJnaW4tdG9wOiAtMWVtO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgbGkge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5mZWVkYmFjay1zY29yZS1pbnB1dCBbcm9sZT1cXFwiYnV0dG9uXFxcIl0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIG1hcmdpbjogMCAxZW0gMmVtIDFlbTtcXG4gICAgaGVpZ2h0OiA1MHB4O1xcbiAgICB3aWR0aDogNTBweDtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmZvY3VzIC5mZWVkYmFjay1zY29yZS00IC5mYWNlLCAuZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmhvdmVyIC5mZWVkYmFjay1zY29yZS00IC5mYWNlIHtcXG4gICAgICBmaWxsOiAjNjNhOTZkO1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmZvY3VzIC5mZWVkYmFjay1zY29yZS0zIC5mYWNlLCAuZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmhvdmVyIC5mZWVkYmFjay1zY29yZS0zIC5mYWNlIHtcXG4gICAgICBmaWxsOiAjYTNhYTY2O1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmZvY3VzIC5mZWVkYmFjay1zY29yZS0yIC5mYWNlLCAuZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmhvdmVyIC5mZWVkYmFjay1zY29yZS0yIC5mYWNlIHtcXG4gICAgICBmaWxsOiAjZTM4NzQzO1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmZvY3VzIC5mZWVkYmFjay1zY29yZS0xIC5mYWNlLCAuZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmhvdmVyIC5mZWVkYmFjay1zY29yZS0xIC5mYWNlIHtcXG4gICAgICBmaWxsOiAjYzg1ZTVmO1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmZvY3VzIC5mZWVkYmFjay1zY29yZS10aXRsZSwgLmZlZWRiYWNrLXNjb3JlLWlucHV0IFtyb2xlPVxcXCJidXR0b25cXFwiXTpob3ZlciAuZmVlZGJhY2stc2NvcmUtdGl0bGUge1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmZvY3VzIC5mYWNlLCAuZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmhvdmVyIC5mYWNlIHtcXG4gICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTBweCk7XFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMHB4KTtcXG59XFxuLmZlZWRiYWNrLXNjb3JlLWlucHV0IFtyb2xlPVxcXCJidXR0b25cXFwiXTpmb2N1cyAuc2hhZG93LCAuZmVlZGJhY2stc2NvcmUtaW5wdXQgW3JvbGU9XFxcImJ1dHRvblxcXCJdOmhvdmVyIC5zaGFkb3cge1xcbiAgICAgIHRyYW5zZm9ybTogc2NhbGVYKDAuNykgdHJhbnNsYXRlWCg3LjVweCk7XFxufVxcbi5mZWVkYmFjay1zY29yZS1pbnB1dCAuZmVlZGJhY2stc2NvcmUtdGl0bGUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvdHRvbTogLTJlbTtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgIG1hcmdpbjogYXV0bztcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuLmZlZWRiYWNrLXNjb3JlLWlucHV0IC5mYWNlLWNvbnRhaW5lciB7XFxuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgLmZhY2Uge1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuMnMgZWFzZS1pbjtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4ycyBlYXNlLWluO1xcbiAgICBmaWxsOiAjYTRjM2VmO1xcbn1cXG4uZmVlZGJhY2stc2NvcmUtaW5wdXQgLnNoYWRvdyB7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIC4ycyBlYXNlLWluO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjJzIGVhc2UtaW47XFxuICAgIGZpbGw6ICNCOUI5Qjk7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTQ5MDNkY2NkXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9zY3JpcHRzL3ZpZXdzL1Njb3JlSW5wdXQudnVlXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uZmVlZGJhY2stdGV4dC1pbnB1dCAuZnJvbS1zY29yZS1pbnB1dCB7XFxuICBtYXJnaW4tYm90dG9tOiAyZW07XFxufVxcbi5mZWVkYmFjay10ZXh0LWlucHV0IC5mZWVkYmFjay1zY29yZSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMi41ZW07XFxuICBoZWlnaHQ6IDIuNWVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAxZW07XFxuICBtYXJnaW4tYm90dG9tOiAtMWVtO1xcbn1cXG4uZmVlZGJhY2stdGV4dC1pbnB1dCAuZmVlZGJhY2stc2NvcmUtdGl0bGUge1xcbiAgbWFyZ2luLXJpZ2h0OiAxZW07XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTYzMTVhMTM4XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9zY3JpcHRzL3ZpZXdzL1RleHRJbnB1dC52dWVcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZlcnNpb249XFxcIjEuMVxcXCIgaWQ9XFxcImYxXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDM0LjIgMzcuOFxcXCIgc3R5bGU9XFxcImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzQuMiAzNy44O1xcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCIgY2xhc3M9XFxcImZhY2UtY29udGFpbmVyXFxcIj48ZWxsaXBzZSBpZD1cXFwic2hhZG93LTFcXFwiIGNsYXNzPVxcXCJzaGFkb3dcXFwiIGN4PVxcXCIxNy4zXFxcIiBjeT1cXFwiMzcuMlxcXCIgcng9XFxcIjlcXFwiIHJ5PVxcXCIwLjZcXFwiPjwvZWxsaXBzZT48cGF0aCBpZD1cXFwiZmFjZS0xXFxcIiBjbGFzcz1cXFwiZmFjZVxcXCIgZD1cXFwiTTE3LjEsMzQuM0M3LjYsMzQuMywwLDI2LjYsMCwxNy4xQzAsNy43LDcuNiwwLDE3LjEsMHMxNy4xLDcuNywxNy4xLDE3LjEgQzM0LjMsMjYuNiwyNi42LDM0LjMsMTcuMSwzNC4zeiBNMTcuMSwyLjlDOS4yLDIuOSwyLjgsOS4zLDIuOCwxNy4xYzAsNy45LDYuNCwxNC4zLDE0LjMsMTQuM1MzMS40LDI1LDMxLjQsMTcuMSBDMzEuNCw5LjMsMjUsMi45LDE3LjEsMi45eiBNMTEuNCwxNC4zYy0xLjYsMC0yLjktMS4zLTIuOS0yLjlzMS4zLTIuOSwyLjktMi45czIuOSwxLjMsMi45LDIuOVMxMywxNC4zLDExLjQsMTQuM3ogTTIyLjgsMTQuMyBjLTEuNiwwLTIuOS0xLjMtMi45LTIuOXMxLjMtMi45LDIuOS0yLjlzMi45LDEuMywyLjksMi45UzI0LjQsMTQuMywyMi44LDE0LjN6IE0yNC42LDI2LjFjLTAuOCwwLjItMS42LTAuMi0xLjgtMC45IGMtMC43LTIuNC0yLjktNC01LjQtNHMtNC43LDEuNi01LjQsNGMtMC4yLDAuOC0xLDEuMi0xLjgsMC45Yy0wLjgtMC4yLTEuMi0xLTAuOS0xLjhjMS4xLTMuNiw0LjQtNiw4LjItNnM3LjEsMi40LDguMiw2IEMyNS44LDI1LjEsMjUuNCwyNS44LDI0LjYsMjYuMXpcXFwiPjwvcGF0aD48L3N2Zz5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2ltYWdlcy9mYWNlMS5zdmdcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZlcnNpb249XFxcIjEuMVxcXCIgaWQ9XFxcImYyXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDM0LjIgMzcuOFxcXCIgc3R5bGU9XFxcImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzQuMiAzNy44O1xcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCIgY2xhc3M9XFxcImZhY2UtY29udGFpbmVyXFxcIj48ZWxsaXBzZSBpZD1cXFwic2hhZG93LTJcXFwiIGNsYXNzPVxcXCJzaGFkb3dcXFwiIGN4PVxcXCIxNy4zXFxcIiBjeT1cXFwiMzcuMlxcXCIgcng9XFxcIjlcXFwiIHJ5PVxcXCIwLjZcXFwiPjwvZWxsaXBzZT48cGF0aCBpZD1cXFwiZmFjZS0yXFxcIiBjbGFzcz1cXFwiZmFjZVxcXCIgZD1cXFwiTTE3LjEsMzQuM0M3LjYsMzQuMywwLDI2LjYsMCwxNy4xQzAsNy43LDcuNiwwLDE3LjEsMHMxNy4xLDcuNywxNy4xLDE3LjEgQzM0LjMsMjYuNiwyNi42LDM0LjMsMTcuMSwzNC4zeiBNMTcuMSwyLjlDOS4yLDIuOSwyLjgsOS4zLDIuOCwxNy4xYzAsNy45LDYuNCwxNC4zLDE0LjMsMTQuM1MzMS40LDI1LDMxLjQsMTcuMSBDMzEuNCw5LjMsMjUsMi45LDE3LjEsMi45eiBNMTEuNCwxNC4zYy0xLjYsMC0yLjktMS4zLTIuOS0yLjlzMS4zLTIuOSwyLjktMi45czIuOSwxLjMsMi45LDIuOVMxMywxNC4zLDExLjQsMTQuM3ogTTIyLjgsMTQuMyBjLTEuNiwwLTIuOS0xLjMtMi45LTIuOXMxLjMtMi45LDIuOS0yLjlzMi45LDEuMywyLjksMi45UzI0LjQsMTQuMywyMi44LDE0LjN6IE0yMy4yLDIwLjZIMTEuN2MtMS4xLDAtMiwwLjktMiwyYzAsMS4xLDAuOSwyLDIsMiBoMTEuNWMxLjEsMCwyLTAuOSwyLTJDMjUuMiwyMS41LDI0LjMsMjAuNiwyMy4yLDIwLjZ6XFxcIj48L3BhdGg+PC9zdmc+XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbWFnZXMvZmFjZTIuc3ZnXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJmM1xcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgeD1cXFwiMHB4XFxcIiB5PVxcXCIwcHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAzNC4yIDM3LjhcXFwiIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDM0LjIgMzcuODtcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiIGNsYXNzPVxcXCJmYWNlLWNvbnRhaW5lclxcXCI+PGVsbGlwc2UgaWQ9XFxcInNoYWRvdy0zXFxcIiBjbGFzcz1cXFwic2hhZG93XFxcIiBjeD1cXFwiMTcuM1xcXCIgY3k9XFxcIjM3LjJcXFwiIHJ4PVxcXCI5XFxcIiByeT1cXFwiMC42XFxcIj48L2VsbGlwc2U+PHBhdGggaWQ9XFxcImZhY2UtM1xcXCIgY2xhc3M9XFxcImZhY2VcXFwiIGQ9XFxcIk0xNy4xLDM0LjNDNy42LDM0LjMsMCwyNi42LDAsMTcuMUMwLDcuNyw3LjYsMCwxNy4xLDBzMTcuMSw3LjcsMTcuMSwxNy4xIEMzNC4zLDI2LjYsMjYuNiwzNC4zLDE3LjEsMzQuM3ogTTE3LjEsMi45QzkuMiwyLjksMi44LDkuMywyLjgsMTcuMWMwLDcuOSw2LjQsMTQuMywxNC4zLDE0LjNTMzEuNCwyNSwzMS40LDE3LjEgQzMxLjQsOS4zLDI1LDIuOSwxNy4xLDIuOXogTTExLjQsMTQuM2MtMS42LDAtMi45LTEuMy0yLjktMi45czEuMy0yLjksMi45LTIuOXMyLjksMS4zLDIuOSwyLjlTMTMsMTQuMywxMS40LDE0LjN6IE0xNy4xLDI3LjEgYy0zLjgsMC03LjEtMi40LTguMi02Yy0wLjItMC44LDAuMi0xLjUsMC45LTEuOGMwLjctMC4yLDEuNSwwLjIsMS44LDAuOWMwLjcsMi40LDIuOSw0LDUuNCw0czQuNy0xLjYsNS40LTRjMC4yLTAuOCwxLTEuMiwxLjgtMC45IGMwLjcsMC4yLDEuMiwxLDAuOSwxLjhDMjQuMiwyNC43LDIwLjksMjcuMSwxNy4xLDI3LjF6IE0yMi44LDE0LjNjLTEuNiwwLTIuOS0xLjMtMi45LTIuOXMxLjMtMi45LDIuOS0yLjlzMi45LDEuMywyLjksMi45IFMyNC40LDE0LjMsMjIuOCwxNC4zelxcXCI+PC9wYXRoPjwvc3ZnPlwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW1hZ2VzL2ZhY2UzLnN2Z1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmVyc2lvbj1cXFwiMS4xXFxcIiBpZD1cXFwiZjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgMzQuMiAzNy44XFxcIiBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzNC4yIDM3Ljg7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIiBjbGFzcz1cXFwiZmFjZS1jb250YWluZXJcXFwiPjxlbGxpcHNlIGlkPVxcXCJzaGFkb3ctNFxcXCIgY2xhc3M9XFxcInNoYWRvd1xcXCIgY3g9XFxcIjE3LjNcXFwiIGN5PVxcXCIzNy4yXFxcIiByeD1cXFwiOVxcXCIgcnk9XFxcIjAuNlxcXCI+PC9lbGxpcHNlPjxwYXRoIGlkPVxcXCJmYWNlLTRcXFwiIGNsYXNzPVxcXCJmYWNlXFxcIiBkPVxcXCJNMTcuMSwzNC4zQzcuNiwzNC4zLDAsMjYuNiwwLDE3LjFDMCw3LjcsNy42LDAsMTcuMSwwczE3LjEsNy43LDE3LjEsMTcuMSBDMzQuMywyNi42LDI2LjYsMzQuMywxNy4xLDM0LjN6IE0xNy4xLDIuOUM5LjIsMi45LDIuOCw5LjMsMi44LDE3LjFjMCw3LjksNi40LDE0LjMsMTQuMywxNC4zUzMxLjQsMjUsMzEuNCwxNy4xIEMzMS40LDkuMywyNSwyLjksMTcuMSwyLjl6IE0xMS40LDE0LjNjLTEuNiwwLTIuOS0xLjMtMi45LTIuOXMxLjMtMi45LDIuOS0yLjlzMi45LDEuMywyLjksMi45UzEzLDE0LjMsMTEuNCwxNC4zeiBNMjIuOCwxNC4zIGMtMS42LDAtMi45LTEuMy0yLjktMi45czEuMy0yLjksMi45LTIuOXMyLjksMS4zLDIuOSwyLjlTMjQuNCwxNC4zLDIyLjgsMTQuM3ogTTI1LjMsMTkuM2MtMC4yLTAuMS0wLjUtMC4xLTAuNywwSDEwLjMgYy0wLjIsMC0wLjUsMC0wLjcsMGMtMC44LDAuMi0xLjIsMS0wLjksMS44YzEuMSwzLjYsNC4xLDcuMiw4LjcsNy4yYzQuMiwwLDcuOC0zLjYsOC45LTcuMkMyNi41LDIwLjMsMjYuMSwxOS41LDI1LjMsMTkuM3ogTTE3LjMsMjUuNGMtMS44LDAtMy43LTEuMS00LjktMy4xaDEwQzIxLjEsMjQuMiwxOS4xLDI1LjQsMTcuMywyNS40elxcXCI+PC9wYXRoPjwvc3ZnPlwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW1hZ2VzL2ZhY2U0LnN2Z1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vRmluYWwudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01YzJiYjExMVxcXCIsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9GaW5hbC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkU6XFxcXFN0Y1xcXFxDdXJyaWtpXFxcXGg1cF9yZXBvXFxcXGg1cC1mZWVkYmFja1xcXFxzcmNcXFxcc2NyaXB0c1xcXFx2aWV3c1xcXFxGaW5hbC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBGaW5hbC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNWMyYmIxMTFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi01YzJiYjExMVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2NyaXB0cy92aWV3cy9GaW5hbC52dWVcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDkwM2RjY2RcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1Njb3JlSW5wdXQudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1Njb3JlSW5wdXQudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi00OTAzZGNjZFxcXCIsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TY29yZUlucHV0LnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRTpcXFxcU3RjXFxcXEN1cnJpa2lcXFxcaDVwX3JlcG9cXFxcaDVwLWZlZWRiYWNrXFxcXHNyY1xcXFxzY3JpcHRzXFxcXHZpZXdzXFxcXFNjb3JlSW5wdXQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkgIT09IFwiX19lc01vZHVsZVwifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gU2NvcmVJbnB1dC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNDkwM2RjY2RcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00OTAzZGNjZFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2NyaXB0cy92aWV3cy9TY29yZUlucHV0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi02MzE1YTEzOFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IXNhc3MtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vVGV4dElucHV0LnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9UZXh0SW5wdXQudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi02MzE1YTEzOFxcXCIsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9UZXh0SW5wdXQudnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJFOlxcXFxTdGNcXFxcQ3VycmlraVxcXFxoNXBfcmVwb1xcXFxoNXAtZmVlZGJhY2tcXFxcc3JjXFxcXHNjcmlwdHNcXFxcdmlld3NcXFxcVGV4dElucHV0LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIFRleHRJbnB1dC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNjMxNWExMzhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi02MzE1YTEzOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2NyaXB0cy92aWV3cy9UZXh0SW5wdXQudnVlXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJoNXAtZmVlZGJhY2stc2NvcmVcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJyb2xlXCI6IFwicmVnaW9uXCJcbiAgICB9XG4gIH0sIFtfYygnaDMnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmVlZGJhY2stdGl0bGVcIixcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJpbm5lckhUTUxcIjogX3ZtLl9zKF92bS5tZXNzYWdlKVxuICAgIH1cbiAgfSksIF9jKCd1bCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmZWVkYmFjay1zY29yZS1pbnB1dFwiXG4gIH0sIF92bS5fbCgoX3ZtLmFsdGVybmF0aXZlcyksIGZ1bmN0aW9uKGFsdGVybmF0aXZlKSB7XG4gICAgcmV0dXJuIF9jKCdsaScsIFtfYygnZGl2Jywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJyb2xlXCI6IFwiYnV0dG9uXCIsXG4gICAgICAgIFwidGFiaW5kZXhcIjogXCIwXCJcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdm0uc2VuZFNjb3JlKGFsdGVybmF0aXZlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW19jKCdkaXYnLCB7XG4gICAgICBjbGFzczogYWx0ZXJuYXRpdmUuY2xzLFxuICAgICAgZG9tUHJvcHM6IHtcbiAgICAgICAgXCJpbm5lckhUTUxcIjogX3ZtLl9zKGFsdGVybmF0aXZlLmljb24pXG4gICAgICB9XG4gICAgfSksIF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJmZWVkYmFjay1zY29yZS10aXRsZVwiXG4gICAgfSwgW192bS5fdihfdm0uX3MoYWx0ZXJuYXRpdmUudGl0bGUpKV0pXSldKVxuICB9KSwgMCldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi00OTAzZGNjZFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTQ5MDNkY2NkXCIsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9zY3JpcHRzL3ZpZXdzL1Njb3JlSW5wdXQudnVlXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJoNXAtZmVlZGJhY2stZmluYWxcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJyb2xlXCI6IFwicmVnaW9uXCJcbiAgICB9LFxuICAgIGRvbVByb3BzOiB7XG4gICAgICBcImlubmVySFRNTFwiOiBfdm0uX3MoX3ZtLmZpbmlzaGVkVGV4dClcbiAgICB9XG4gIH0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTVjMmJiMTExXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNWMyYmIxMTFcIixcInByZXNlcnZlV2hpdGVzcGFjZVwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL3NjcmlwdHMvdmlld3MvRmluYWwudnVlXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmZWVkYmFjay10ZXh0LWlucHV0XCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwicm9sZVwiOiBcInJlZ2lvblwiXG4gICAgfVxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmcm9tLXNjb3JlLWlucHV0XCJcbiAgfSwgW19jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZlZWRiYWNrLXNjb3JlXCIsXG4gICAgY2xhc3M6IF92bS5hbHRlcm5hdGl2ZS5jbHNcbiAgfSksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZlZWRiYWNrLXNjb3JlLXRpdGxlXCJcbiAgfSwgW192bS5fdihfdm0uX3ModGhpcy5hbHRlcm5hdGl2ZS50aXRsZSkpXSksIF9jKCdyb3V0ZXItbGluaycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0b1wiOiBcIi9zY29yZS1pbnB1dFwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiQ2hhbmdlXCIpXSldLCAxKSwgX2MoJ2RpdicsIHtcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJpbm5lckhUTUxcIjogX3ZtLl9zKF92bS5sYWJlbFRleHRJbnB1dClcbiAgICB9XG4gIH0pLCBfYygndGV4dGFyZWEnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgdmFsdWU6IChfdm0udGV4dCksXG4gICAgICBleHByZXNzaW9uOiBcInRleHRcIlxuICAgIH1dLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInJvd3NcIjogXCI0XCIsXG4gICAgICBcInBsYWNlaG9sZGVyXCI6IFwiWW91ciBGZWVkYmFja1wiXG4gICAgfSxcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJ2YWx1ZVwiOiAoX3ZtLnRleHQpXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybjsgfVxuICAgICAgICBfdm0udGV4dCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBfYygnYnV0dG9uJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvbiBidXR0b24tcHJpbWFyeVwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImRpc2FibGVkXCI6IF92bS50ZXh0Lmxlbmd0aCA8IDFcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICByZXR1cm4gX3ZtLnNlbmRUZXh0KF92bS50ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fdihcIlNlbmRcIildKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTYzMTVhMTM4XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNjMxNWExMzhcIixcInByZXNlcnZlV2hpdGVzcGFjZVwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL3NjcmlwdHMvdmlld3MvVGV4dElucHV0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTQ5MDNkY2NkXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TY29yZUlucHV0LnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMjkxMzAxYzRcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDkwM2RjY2RcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1Njb3JlSW5wdXQudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTQ5MDNkY2NkXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TY29yZUlucHV0LnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNDkwM2RjY2RcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL3NjcmlwdHMvdmlld3MvU2NvcmVJbnB1dC52dWVcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi02MzE1YTEzOFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vVGV4dElucHV0LnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMGU2OGUyYTJcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNjMxNWExMzhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1RleHRJbnB1dC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNjMxNWExMzhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1RleHRJbnB1dC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTYzMTVhMTM4XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9zY3JpcHRzL3ZpZXdzL1RleHRJbnB1dC52dWVcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=